<!-- TOC -->

- [lab_answer](#lab_answer)
    - [[思考1]](#思考1)
    - [[思考2]](#思考2)

<!-- /TOC -->

# lab_answer

## [思考1]

[思考1.1] 高级语言程序需要经过预处理,编译,汇编,链接,最后得到机器指令,才能真正地在机器上得到运行.

[思考1.2] 既然操作系统也是用C语言来写的,那么它和其他普通的C语言代码一样,也同样需要经过预处理,编译,汇编,链接的过程才能得到运行.

[思考1.3] 其实现在操作系统如果想要得到运行,就需要一台已经装好操作系统和编译器的机器,在这台机器上,把自己想运行的操作系统转换成字节流,这样就可以直接得到运行.

>如果想要在x86的架构的机器上对MIPS架构的操作系统进行编译,还需要使用到交叉编译器来解决体系结构之间的差异.

其实这里如果仔细思考还是会发现问题,如果想要运行一个操作系统需要另一个已经安装好的操作系统,那么世界上第一个操作系统是怎么来的.关于第一个操作系统的问题并不好回答,因为很难定义什么时候开始有真正意义上的操作系统.简单来说可以认为,最早的操作系统是直接使用机器语言来写的.

>(注)感觉这部分对第一个操作系统的历史写的并不好,百度查到的也讲不清楚,知乎给了几个维基的链接家里没有v4的vps也翻不出去.
[历史上第一个操作系统是什么，怎么写出来的？(知乎)](https://www.zhihu.com/question/20645253)
[wiki 1](https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/History_of_operating_systems)
[wiki 2](https://link.zhihu.com/?target=http%3A//zh.wikipedia.org/wiki/%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E5%258E%2586%25E5%258F%25B2)

[思考1.4] 早期的程序员其实是直接手写机器码来对机器进行操作,例如对寄存器进行赋值,手动跳转等.因此并不需要经过编译,汇编,链接等过程,代码就能直接得到运行.因此很容易可以想到第一个编译器其实就是在这种远古时代中使用机器码写出来的,然后在这个编译器的基础上,经过不断地升级迭代,最终形成了现在的各种编译器.

>在GNU(一种操作系统)中,就有一套二进制工具集,叫做binutils,主要包括ld链接器和as汇编器.

## [思考2]

如果操作系统将TLB进行保存,很明显是一个用空间来换取时间的策略.但是在现在的商业操作系统中,并没有提供保存TLB的功能,因此TLB是直接被刷新掉的.但是其实内核空间的东西,在进程切换的时候是不受影响的,但是关于这部分地址映射的TLB却被无故清空了,带来了性能上的损失.

>(注)感觉联系一下工业界或者学术界对TLB最新的功能扩展会比较好