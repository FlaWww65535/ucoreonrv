{"./":{"url":"./","title":"Introduction","keywords":"","body":"uCore OS(on RISC-V32)实验指导书 ucore实验指导书 ucore labs 1-8 源码和参考答案 实验总体流程 认真上操作系统的理论课程； 阅读ucore实验指导书，并参考其内容完成联系和实验报告; 在实验环境中完成实验并提交到自己的github上； 遇到问题，首先查询手册等其他资料，先自行解决； 如若不能解决，可在飞书群里提问，可以互相讨论，有助教老师答疑。 学习目标与对应手段 掌握OS基本概念：通过上课与学习教材，能理解OS原理与概念；阅读指导书并分析源码，能理解lab_codes_answer的labs运行结果。 掌握OS设计实现：在1的基础上，能够通过编程完成lab_codes的8个lab实验中的基本练习和实验报告。 掌握OS核心功能：在2的基础上，能够通过编程完成lab_codes的8个lab实验中的challenge练习。 掌握OS科学研究：联系老师，加入实验室，开始科研吧。 友情提示 课程铺垫——计算机组成原理、C语言、数据结构 工具掌握——命令行 shell、软件管理 apt-get/aptitude、版本管理 git/github、代码阅读 understand/VSCode、代码比较 diff/meld、开发编译调试 gcc/gdb/make、硬件模拟器 qemu、md文档编写 Typora 实验报告要求 独立完成； 用Markdown语言编写； 报告内容包括但不仅限于：实验目的、实验内容、实验步骤、实验结果、遇到的问题与解决方法； 报告编写完需按时发送给助教并上传到自己的github仓库里。 维护者 kelee@mail.nankai.edu.cn 如若对本指导书有任何疑问，请联系维护者！ Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:14:09 "},"Lab0/":{"url":"Lab0/","title":"LAB0","keywords":"","body":"LAB0：操作系统实验准备 学习与操作系统实验相关的前导知识，其主要包括实验环境、实验步骤、实验工具、uCore历史、RISC-V简介。 配置实验所需要的环境与软件。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:19:50 "},"Lab0/实验目的.html":{"url":"Lab0/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 了解操作系统开发实验环境 学会使用Ubuntu操作系统 熟悉命令行方式的编译、调试工程 掌握基于硬件模拟器的调试技术 学会使用基本的开发工具 掌握RISCV-32汇编语言 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:22:13 "},"Lab0/实验内容.html":{"url":"Lab0/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 阅读实验指导书内容以及涉及的官方文档或者教程。 对于实验指导书未涉及的内容能自行动手查询资料学习。 安装Ubuntu操作系统。 安装推荐的开发工具，若对某些工具情有独钟亦可。 安装依赖包、硬件模拟器、调试工具后尝试进行联合调试。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:49:03 "},"Lab0/前导知识.html":{"url":"Lab0/前导知识.html","title":"前导知识","keywords":"","body":"前导知识 该模块是LAB0的第一个模块，主要就是阅读学习相关的知识，对OS实验有一个基本的了解，看一下我们接下来一个学期到底要做什么，要实现什么样的一个东西，而这个东西又是基于什么基础慢慢搭建起来的。要搭建房子需要各种工具，工欲善其事必先利其器，所以要学会使用主要的开发调试工具，能让我们实验过程变得非常愉快。 最后由于我们是基于RISC-V指令集来完成实验，当然要掌握这门指令集的所有东西啦，幸运的是，你选择的是最简单的指令集，有没有开心一点呢？ [!NOTE|style:flat] 千万不要嫌接下来的前导知识杂没有用哦，答应我，一定要认认真真的看哈~ Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 12:43:57 "},"Lab0/前导知识/了解uCore.html":{"url":"Lab0/前导知识/了解uCore.html","title":"了解uCore","keywords":"","body":"了解uCore 2006年, MIT的Frans Kaashoek等人参考PDP-11上的UNIX Version 6写了一个可在x86指令集架构上运行的操作系统xv6（基于MIT License)。 2010年, 清华大学操作系统教学团队参考MIT的教学操作系统xv6, 开发了在x86指令集架构上运行的操作系统ucore, 多年来作为操作系统课程的实验框架使用, 已经成为了大家口中的\"祖传实验\". ucore麻雀虽小，五脏俱全。在不超过5k的代码量中包含虚拟内存管理、进程管理、处理器调度、同步互斥、进程间通信、文件系统等主要内核功能，充分体现了“小而全”的指导思想。 ucore的运行环境可以是真实的计算机（包括小型智能设备）。一开始ucore是运行在x86指令集架构上的，到了如今，x86指令集架构的问题渐渐开始暴露出来。 虽然在PC平台上占据绝对主流，但出于兼容性考虑x86架构仍然保留了许多的历史包袱，用于教学的时候总有些累赘。另一方面，为了更好的和目前5G、物联网技术的发展衔接，将ucore移植到RISC-V架构势在必行。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-16 11:19:34 "},"Lab0/前导知识/了解RISC-V.html":{"url":"Lab0/前导知识/了解RISC-V.html","title":"了解RISC-V","keywords":"","body":"了解RISC-V 发明 RISC发明者是美国加州大学伯克利分校教师David Patterson，RISC-V（拼做risk-five）是第五代精简指令集，也是由David Patterson指导的项目。2010年伯克利大学并行计算实验室(Par Lab) 的1位教授和2个研究生想要做一个项目，需要选一种计算机架构来做。当时面临的的是选择X86、ARM，还是其他指令集，不管选择哪个都或多或少有些问题，比如授权费价格高昂，不能开源，不能扩展更改等等。所以他们在2010年5月开始规划自己做一个新的、开源的指令集，就是RISC-V。 接着时间到2015年，这个指令集在学术界已经开始出名了，这时为了更好的推动这个指令集在技术和商业上的发展，3位创始人大佬做了下面两件事情。 技术方向，成立RISC-V基金会，维护指令集架构的完整性和非碎片化。 商业方向，成立SiFive公司，推动RISC-V的商业化。 基金会会员 目前加入RISC-V基金会的中国企业和机构有：阿里巴巴、华为、中科院计算所、华米科技、智芯科技、浪潮等。（具体会员名单可以在这里查看） 特点 设计哲学-简单就是美 无病一身轻——架构的篇幅。目前的“RISC-V架构文档”分为“指令集文档”（riscv-spec-v2.2.pdf）和“特权架构文档”（riscv-privileged-v1.10.pdf）。“指令集文档”的篇幅为145页，而“特权架构文档”的篇幅也仅为91页。熟悉体系结构的工程师仅需一至两天便可将其通读，虽然“RISC-V的手册”还在不断地丰富，但是相比“x86的架构文档”与“ARM的架构文档”，RISC-V的篇幅可以说是极其短小精悍。 [!NOTE|style:flat] 一定要仔细阅读《RISC-V手册》哦！！ 能屈能伸——模块化的指令集。RISC-V架构相比其他成熟的商业架构的最大一个不同还在于它是一个模块化的架构。因此，RISC-V架构不仅短小精悍，而且其不同的部分还能以模块化的方式组织在一起，从而试图通过一套统一的架构满足各种不同的应用。这种模块化是x86与ARM架构所不具备的。以ARM的架构为例，ARM的架构分为A、R和M三个系列，分别针对于Application（应用操作系统）、Real-Time（实时）和Embedded（嵌入式）三个领域，彼此之间并不兼容。模块化的RISC-V架构能够使得用户能够灵活选择不同的模块组合，以满足不同的应用场景，可以说是“老少咸宜” 浓缩的都是精华——指令的数量。短小精悍的架构以及模块化的哲学，使得RISC-V架构的指令数目非常的简洁。基本的RISC-V指令数目仅有40多条，加上其他的模块化扩展指令总共几十条指令。 指令集简介 模块化的指令子集。RISC-V的指令集使用模块化的方式进行组织，每一个模块使用一个英文字母来表示。RISC-V最基本也是唯一强制要求实现的指令集部分是由I字母表示的基本整数指令子集，使用该整数指令子集，便能够实现完整的软件编译器。其他的指令子集部分均为可选的模块，具有代表性的模块包括M/A/F/D/C。 规整的指令编码。RISC-V的指令集编码非常的规整，指令所需的通用寄存器的索引（Index）都被放在固定的位置。因此指令译码器（Instruction Decoder）可以非常便捷的译码出寄存器索引然后读取通用寄存器组（Register File，Regfile）。 优雅的压缩指令子集。基本的RISC-V基本整数指令子集（字母I表示 ）规定的指令长度均为等长的32位，这种等长指令定义使得仅支持整数指令子集的基本RISC-V CPU非常容易设计。但是等长的32位编码指令也会造成代码体积（Code Size）相对较大的问题。为了满足某些对于代码体积要求较高的场景（譬如嵌入式领域），RISC-V定义了一种可选的压缩（Compressed）指令子集，由字母C表示，也可以由RVC表示。RISC-V具有后发优势，从一开始便规划了压缩指令，预留了足够的编码空间，16位长指令与普通的32位长指令可以无缝自由地交织在一起，处理器也没有定义额外的状态。 特权模式。RISC-V架构定义了三种工作模式，又称特权模式（Privileged Mode）：Machine Mode：机器模式，简称M Mode。Supervisor Mode：监督模式，简称S Mode。User Mode：用户模式，简称U Mode。RISC-V架构定义M Mode为必选模式，另外两种为可选模式。通过不同的模式组合可以实现不同的系统。 自定制指令扩展。除了上述阐述的模块化指令子集的可扩展、可选择，RISC-V架构还有一个非常重要的特性，那就是支持第三方的扩展。用户可以扩展自己的指令子集，RISC-V预留了大量的指令编码空间用于用户的自定义扩展，同时，还定义了四条Custom指令可供用户直接使用，每条Custom指令都有几个比特位的子编码空间预留，因此，用户可以直接使用四条Custom指令扩展出几十条自定义的指令。 其他特点 可配置的通用寄存器组、简洁的存储器访问指令、高效的分支跳转指令、简洁的子程序调用、无条件码执行、无分支延迟槽、简洁的运算指令。 [!TIP|style:flat|label:友情链接] RISC-V基金会 中国开放指令生态（RISC-V）联盟 赛昉科技 终于有人把RISC-V讲明白了 什么是RISC-V Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-18 11:12:17 "},"Lab0/前导知识/了解OS实验.html":{"url":"Lab0/前导知识/了解OS实验.html","title":"了解OS实验","keywords":"","body":"了解OS实验 写一个操作系统难吗？别被现在上百万行的Linux和Windows操作系统吓倒。当年Thompson趁他老婆带着小孩度假留他一人在家时，写了UNIX；当年Linus还是一个21岁大学生时完成了Linux雏形。站在这些巨人的肩膀上，我们能否也尝试一下做“巨人”的滋味呢？ 实验内容 那我们准备如何一步一步来实现ucore呢？根据一个操作系统的设计实现过程，我们可以有如下的实验步骤： 启动操作系统的bootloader:OpenSBI。了解操作系统启动前的状态和要做的准备工作，了解运行操作系统的硬件支持，操作系统如何加载到内存中，理解两类中断--“外设中断”，“陷阱中断”等； 物理内存管理子系统。用于理解RISC-V分段/分页模式，了解操作系统如何管理物理内存； 虚拟内存管理子系统。通过页表机制和换入换出（swap）机制，以及中断-“故障中断”、缺页故障处理等，实现基于页的内存替换算法； 内核线程子系统。用于了解如何创建相对与用户进程更加简单的内核态线程，如果对内核线程进行动态管理等； 用户进程管理子系统。用于了解用户态进程创建、执行、切换和结束的动态管理过程，了解在用户态通过系统调用得到内核态的内核服务的过程； 处理器调度子系统。用于理解操作系统的调度过程和调度算法； 同步互斥与进程间通信子系统。了解进程间如何进行信息交换和共享，并了解同步互斥的具体实现以及对系统性能的影响，研究死锁产生的原因，以及如何避免死锁； 文件系统。了解文件系统的具体实现，与进程管理等的关系，了解缓存对操作系统IO访问的性能改进，了解虚拟文件系统（VFS）、buffer cache和disk driver之间的关系。 其中每个开发步骤都是建立在上一个步骤之上的，就像搭积木，从一个一个小木块，最终搭出来一个小房子。在搭房子的过程中，完成从理解操作系统原理到实践操作系统设计与实现的探索过程。这个房子最终的建筑架构和建设进度如下图所示： 开发OS实验的步骤 本次OS实验大致可以通过如下过程就可以完成使用： 学习相关理论知识 建立LAB实验环境，采用VMware虚拟机的最简单方式完成 阅读本LAB实验指导书，了解实验要求 下载源码 进入各个OS实验工程目录 例如：cd labcodes/lab1 根据实验要求阅读并修改代码 编译源码 例如执行：make 如果不通过则返回步骤3 如果实现不正确（即看到步骤6的输出存在不是OK的情况）则返回3 如果实现基本正确（即看到6的输出都是OK）则push到自己github仓库 编写实验报告，发送到助教邮箱，并push到github仓库 [!NOTE|style:flat] 可以通过make qemu让OS实验工程在qemu上运行；可以通过make debug或make debug-nox命令实现通过gdb远程调试 OS实验工程。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-18 10:46:31 "},"Lab0/前导知识/了解实验环境.html":{"url":"Lab0/前导知识/了解实验环境.html","title":"了解实验环境","keywords":"","body":"了解实验环境 在实验中，我们使用的系统环境是Ubuntu18.04。在实验过程中，我们需要了解基于命令行方式的编译、调试、运行操作系统的实验方法。为此，需要了解基本的Linux命令行使用。 [!TIP|style:flat] 当然现在只是了解一下，具体的操作还是要在安装好虚机以后再来哦~ 命令模式的基本结构和概念 Ubuntu是图形界面友好和易操作的Linux发行版，但有时只需执行几条简单的指令就可以完成繁琐的鼠标点击才能完成的操作。Linux的命令行操作模式功能可以实现你需要的所有操作。简单的说，命令行就是基于字符命令的用户界面，也被称为文本操作模式。绝大多数情况下， 用户通过输入一行或多行命令直接与计算机互动，来实现对计算机的操作。 如何进入命令模式 假设使用默认的图形界面为GNOME的任意版本Ubuntu Linux。点击鼠标右键->终端，就可以启动名为terminal程序，从而可以在此软件界面中进行命令行操作。 打开terminal程序后你首先可能会注意到类似下面的界面： kelee@ubuntu:~$ 你所看到的这些被称为命令终端提示符，它表示计算机已就绪，正在等待着用户输入操作指令。以我的屏幕画面为例，“kelee\"是当前所登录的用户名，“ubuntu”是这台计算机的主机名，“~”表示当前目录。此时输入任何指令按回车之后该指令将会提交到计算机运行，比如你可以输入命令：ls 再按下回车： ls [ENTER] 注意：[ENTER]是指输入完ls后按下回车键，而不是叫你输入这个单词，ls这个命令将会列出你当前所在目录里的所有文件和子目录列表。 下面介绍bash shell程序的基本使用方法，它是ubuntu缺省的外壳程序。 常用指令 查询文件列表：(ls) kelee@ubuntu:~$ ls Desktop Downloads Music Public Templates Documents examples.desktop Pictures riscv Videos ls命令默认状态下将按首字母升序列出你当前文件夹下面的所有内容，但这样直接运行所得到的信息也是比较少的，通常它可以结合以下这些参数运行以查询更多的信息： ls / # 将列出根目录'/'下的文件清单.如果给定一个参数，则命令行会把该参数当作命令行的工作目录。换句话说，命令行不再以当前目录为工作目录。 ls -l # 将给你列出一个更详细的文件清单. ls -a # 将列出包括隐藏文件(以.开头的文件)在内的所有文 件. ]ls -h # 将以KB/MB/GB的形式给出文件大小,而不是以纯粹的Bytes. 查询当前所在目录：(pwd) kelee@ubuntu:~$ pwd /home/kelee 进入其他目录：(cd) kelee@ubuntu:~$ cd riscv kelee@ubuntu:~/riscv$ pwd /home/kelee/riscv kelee@ubuntu:~/riscv$ 上面例子中，当前目录原来是/home/kelee,执行cd riscv之后再运行pwd可以发现，当前目录已经改为/riscv了。 在屏幕上输出字符： (echo) kelee@ubuntu:~$ echo \"Hello World\" Hello World 这是一个很有用的命令，它可以在屏幕上输入你指定的参数(\"\"号中的内容)，当然这里举的这个例子中它没有多大的实际意义，但随着你对LINUX指令的不断深入，就会发现它的价值所在。 显示文件内容：cat kelee@ubuntu:~$ cat tempfile.txt Roses are red. Violets are blue, and you have the bird-flue! 也可以使用less或more来显示比较大的文本文件内容。 复制文件： cp kelee@ubuntu:~$ cp tempfile.txt tempfile_copy.txt kelee@ubuntu:~$ cat tempfile_copy.txt Roses are red. Violets are blue, and you have the bird-flue! 移动文件：mv kelee@ubuntu:~$ ls Desktop Downloads Music Public tempfile_copy.txt Templates Documents examples.desktop Pictures riscv tempfile.txt Videos kelee@ubuntu:~$ mv tempfile_copy.txt tempfile_mv.txt kelee@ubuntu:~$ ls Desktop Downloads Music Public tempfile_mv.txt Templates Documents examples.desktop Pictures riscv tempfile.txt Videos 注意：在命令操作时系统基本上不会给你什么提示，当然，绝大多数的命令可以通过加上一个参数-v来要求系统给出执行命令的反馈信息； kelee@ubuntu:~$ mv -v tempfile_mv.txt tempfile_mv_v.txt renamed 'tempfile_mv.txt' -> 'tempfile_mv_v.txt' 建立一个空文本文件：touch kelee@ubuntu:~$ ls Desktop Downloads Music Public tempfile_mv_v.txt Templates Documents examples.desktop Pictures riscv tempfile.txt Videos kelee@ubuntu:~$ touch file1.txt kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt Videos Documents file1.txt Public tempfile.txt Downloads Music riscv Templates 建立一个目录：mkdir kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt Videos Documents file1.txt Public tempfile.txt Downloads Music riscv Templates kelee@ubuntu:~$ mkdir test_dir kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt test_dir Documents file1.txt Public tempfile.txt Videos Downloads Music riscv Templates 删除文件/目录：rm kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt test_dir Documents file1.txt Public tempfile.txt Videos Downloads Music riscv Templates kelee@ubuntu:~$ rm tempfile_mv_v.txt kelee@ubuntu:~$ ls -p Desktop/ examples.desktop Pictures/ tempfile.txt Videos/ Documents/ file1.txt Public/ Templates/ Downloads/ Music/ riscv/ test_dir/ kelee@ubuntu:~$ rm test_dir rm: cannot remove 'test_dir': Is a directory kelee@ubuntu:~$ rm -R test_dir kelee@ubuntu:~$ ls Desktop Downloads file1.txt Pictures riscv Templates Documents examples.desktop Music Public tempfile.txt Videos 在上面的操作：首先我们通过ls命令查询可知当前目下有两个文件和一个文件夹； [1] 你可以用参数 -p来让系统显示某一项的类型，比如是文件/文件夹/快捷链接等等； [2] 接下来我们用rm -i尝试删除文件，-i参数是让系统在执行删除操作前输出一条确认提示；i(interactive)也就是交互性的意思； [3] 当我们尝试用上面的命令去删除一个文件夹时会得到错误的提示，因为删除文件夹必须使用-R(recursive,循环）参数 特别提示：在使用命令操作时，系统假设你很明确自己在做什么，它不会给你太多的提示，比如你执行rm -Rf /，它将会删除你硬盘上所有的东西，并且不会给你任何提示，所以，尽量在使用命令时加上-i的参数，以让系统在执行前进行一次确认，防止你干一些蠢事。如 果你觉得每次都要输入-i太麻烦，你可以执行以下的命令，让－i成为默认参数： alias rm='rm -i' 查询当前进程：ps kelee@ubuntu:~$ ps PID TTY TIME CMD 3356 pts/0 00:00:00 bash 3659 pts/0 00:00:00 ps 这条命令会例出你所启动的所有进程； ps -a #可以例出系统当前运行的所有进程，包括由其他用户启动的进程； ps auxww #是一条相当人性化的命令，它会例出除一些很特殊进程以外的所有进程，并会以一个高可读的形式显示结果，每一个进程都会有较为详细的解释； 基本命令的介绍就到此为止，你可以访问网络得到更加详细的Linux命令介绍。 控制流程 输入/输出 input用来读取你通过键盘（或其他标准输入设备）输入的信息，output用于在屏幕（或其他标准输出设备）上输出你指定的输出内容.另外还有一些标准的出错提示也是通过这个命令来实现的。通常在遇到操作错误时，系统会自动调用这个命令来输出标准错误提示； 我们能重定向命令中产生的输入和输出流的位置。 重定向 如果你想把命令产生的输出流指向一个文件而不是（默认的）终端，你可以使用如下的语句： kelee@ubuntu:~$ ls >file2.txt kelee@ubuntu:~$ cat file2.txt Desktop Documents Downloads examples.desktop file1.txt file2.txt Music Pictures Public riscv tempfile.txt Templates Videos 以上例子将创建文件file2.txt如果file2.txt不存在的话。注意：如果file2.txt已经存在，那么上面的命令将复盖文件的内容。如果你想将内容添加到已存在的文件内容的最后，那你可以用下面这个语句： command >> filename 示例: kelee@ubuntu:~$ ls >>file2.txt kelee@ubuntu:~$ cat file2.txt Desktop Documents Downloads examples.desktop file1.txt file2.txt Music Pictures Public riscv tempfile.txt Templates Videos Desktop Documents Downloads examples.desktop file1.txt file2.txt Music Pictures Public riscv tempfile.txt Templates Videos 在这个例子中，你会发现原有的文件中添加了新的内容。接下来我们会见到另一种重定向方式：我们将把一个文件的内容作为将要执行的命令的输入。以下是这个语句： command 示例: kelee@ubuntu:~$ sort 管道 Linux的强大之处在于它能把几个简单的命令联合成为复杂的功能，通过键盘上的管道符号'|' 完成。现在，我们来排序上面的\"grep\"命令： kelee@ubuntu:~$ grep -i 'D' result.txt kelee@ubuntu:~$ cat result.txt Desktop Desktop Documents Documents Downloads Downloads examples.desktop examples.desktop Videos Videos 搜索 file2.txt 中的d字母，将输出分类并写入分类文件到 result.txt 。 有时候用ls列出很多命令的时候很不方便 这时“｜”就充分利用到了 ls -l | less 慢慢看吧. 后台进程 CLI 不是系统的串行接口。您可以在执行其他命令时给出系统命令。要启动一个进程到后台，追加一个“&”到命令后面。 sleep 60 & ls 睡眠命令在后台运行，您依然可以与计算机交互。除了不同步启动命令以外，最好把 '&' 理解成 ';'。 如果您有一个命令将占用很多时间，您想把它放入后台运行，也很简单。只要在命令运行时按下ctrl-z，它就会停止。然后键入 bg使其转入后台。fg 命令可使其转回前台。 sleep 60 # 这表示敲入Ctrl+Z键 bg fg 最后，您可以使用 ctrl-c 来杀死一个前台进程。 环境变量 特殊变量。PATH, PS1, ... 不显示中文 可通过执行如下命令避免显示乱码中文。在一个shell中，执行： export LANG=”” 这样在这个shell中，output信息缺省时英文。 获得软件包 命令行获取软件包 Ubuntu 下可以使用 apt-get 命令，apt-get 是一条 Linux 命令行命令，适用于 deb 包管理式的操作系统，主要用于自动从互联网软件库中搜索、安装、升级以及卸载软件或者操作系统。一般需要 root 执行权限，所以一般跟随 sudo 命令，如： sudo apt-get install gcc [ENTER] 常见的以及常用的 apt 命令有： apt-get install 下载 以及所依赖的软件包，同时进行软件包的安装或者升级。 apt-get remove 移除 以及所有依赖的软件包。 apt-cache search 搜索满足 的软件包。 apt-cache show/showpkg 显示软件包 的完整描述。 例如： kelee@ubuntu:~$ apt-cache search aptitude aptitude - terminal-based package manager aptitude-common - architecture independent files for the aptitude package manager aptitude-doc-en - English manual for aptitude, a terminal-based package manager libcwidget-dev - high-level terminal interface library for C++ (development files) apt-cacher - Caching proxy server for Debian/Ubuntu software repositories apticron - Simple tool to mail about pending package updates - cron version apticron-systemd - Simple tool to mail about pending package updates - systemd version aptitude-doc-cs - Czech manual for aptitude, a terminal-based package manager aptitude-doc-es - Spanish manual for aptitude, a terminal-based package manager aptitude-doc-fi - Finnish manual for aptitude, a terminal-based package manager aptitude-doc-fr - French manual for aptitude, a terminal-based package manager aptitude-doc-it - Italian manual for aptitude, a terminal-based package manager aptitude-doc-ja - Japanese manual for aptitude, a terminal-based package manager aptitude-doc-nl - Dutch manual for aptitude, a terminal-based package manager aptitude-doc-ru - Russian manual for aptitude, a terminal-based package manager aptitude-robot - Automate package choice management cron-apt - automatic update of packages using apt-get cupt - flexible package manager -- console interface gbrainy - brain teaser game and trainer to have fun and to keep your brain trained pkgsync - automated package list synchronization wajig - unified package management front-end for Debian kelee@ubuntu:~$ 配置升级源 Ubuntu的软件包获取依赖升级源，通过Software&Updates->Ubuntu Software->Download from:->Other:->China->mirrors.aliyun.com->Choose Server 查找帮助文件 Ubuntu 下提供 man 命令以完成帮助手册得查询。man 是 manual 的缩写，通过 man 命令可以对 Linux 下常用命令、安装软件、以及C语言常用函数等进行查询，获得相关帮助。 例如： kelee@ubuntu:~$ man printf PRINTF(1) User Commands PRINTF(1) NAME printf - format and print data SYNOPSIS printf FORMAT [ARGUMENT]... printf OPTION DESCRIPTION Print ARGUMENT(s) according to FORMAT, or execute according to OPTION: --help display this help and exit --version output version information and exit FORMAT controls the output as in C printf. Interpreted sequences are: \\\" double quote \\\\ backslash Manual page printf(1) line 1 (press h for help or q to quit) 通常可能会用到的帮助文件例如： gcc-doc cpp-doc glibc-doc 上述帮助文件可以通过 apt-get 命令或者软件包管理器获得。获得以后可以通过 man 命令进行命令或者参数查询。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-18 11:30:03 "},"Lab0/前导知识/了解开发调试基本工具.html":{"url":"Lab0/前导知识/了解开发调试基本工具.html","title":"了解开发调试基本工具","keywords":"","body":"了解开发调试基本工具 编辑器 Understand 在OS实验网站上有Understand Windows版的资源。该软件是一个阅读代码的很好工具，可以可视化的看到各个函数之间的调用关系，可以很好的找到函数、变量的定义，具体的使用方法以及介绍可以参考该教程。但是就编辑代码来说，不建议使用Understand。 VScode VScode是很好的项目管理、代码编译器工具，集成了git，并且可以安装各类插件支持各种语言，习惯使用visual studio的同学使用起来会非常习惯，具体的下载安装使用方法，可以参考该教程，值得说明的是，我们在编译的时候需要其他工具联合编译，因此可以仅仅把VScode当成没有感情的写代码工具，不由它来编译运行，编译运行交给终端。 [!NOTE|style:flat] VScode 快捷键的使用在Windows和Ubuntu上有些不同哦~ 写完了代码别忘了格式化代码鸭~看起来好舒服的！ 编译器:GCC 在Ubuntu Linux中的C语言编程主要基于GNU C的语法，通过gcc来编译并生成最终执行文件。GNU汇编（assembler）采用的是AT&T汇编格式，Microsoft 汇编采用Intel格式。 编译简单的 C 程序 C 语言经典的入门例子是 Hello World，下面是一示例代码： #include int main(void) { printf(\"Hello, world!\\n\"); return 0; } 我们假定该代码存为文件‘hello.c’。要用 gcc 编译该文件，使用下面的命令： $ gcc -Wall hello.c -o hello 该命令将文件‘hello.c’中的代码编译为机器码并存储在可执行文件 ‘hello’中。机器码的文件名是通过 -o 选项指定的。该选项通常作为命令行中的最后一个参数。如果被省略，输出文件默认为 ‘a.out’。 注意到如果当前目录中与可执行文件重名的文件已经存在，它将被复盖。 选项 -Wall 开启编译器几乎所有常用的警告──强烈建议你始终使用该选项。编译器有很多其他的警告选项，但 -Wall 是最常用的。默认情况下GCC 不会产生任何警告信息。当编写 C 或 C++ 程序时编译器警告非常有助于检测程序存在的问题。 本例中，编译器使用了 -Wall 选项而没产生任何警告，因为示例程序是完全合法的。 要运行该程序，输入可执行文件的路径如下： $ ./hello Hello, world! 这将可执行文件载入内存，并使 CPU 开始执行其包含的指令。 路径 ./ 指代当前目录，因此 ./hello 载入并执行当前目录下的可执行文件 ‘hello’。 AT&T汇编基本语法 Ucore中用到的是AT&T格式的汇编，与Intel格式的汇编有一些不同。二者语法上主要有以下几个不同： * 寄存器命名原则 AT&T: %eax Intel: eax * 源/目的操作数顺序 AT&T: movl %eax, %ebx Intel: mov ebx, eax * 常数/立即数的格式　 AT&T: movl $_value, %ebx Intel: mov eax, _value 把value的地址放入eax寄存器 AT&T: movl $0xd00d, %ebx Intel: mov ebx, 0xd00d * 操作数长度标识 AT&T: movw %ax, %bx Intel: mov bx, ax * 寻址方式 AT&T: immed32(basepointer, indexpointer, indexscale) Intel: [basepointer + indexpointer × indexscale + imm32) 如果操作系统工作于保护模式下，用的是32位线性地址，所以在计算地址时不用考虑segment:offset的问题。上式中的地址应为： imm32 + basepointer + indexpointer × indexscale 下面是一些例子： * 直接寻址 AT&T: foo Intel: [foo] boo是一个全局变量。注意加上$是表示地址引用，不加是表示值引用。对于局部变量，可以通过堆栈指针引用。 * 寄存器间接寻址 AT&T: (%eax) Intel: [eax] * 变址寻址 AT&T: _variable(%eax) Intel: [eax + _variable] AT&T: _array( ,%eax, 4) Intel: [eax × 4 + _array] AT&T: _array(%ebx, %eax,8) Intel: [ebx + eax × 8 + _array] GCC基本内联汇编 GCC 提供了两内内联汇编语句（inline asm statements）：基本内联汇编语句（basic inline asm statement)和扩展内联汇编语句（extended inline asm statement）。GCC基本内联汇编很简单，一般是按照下面的格式： asm(\"statements\"); 例如： asm(\"nop\"); asm(\"cli\"); \"asm\" 和 \"asm\" 的含义是完全一样的。如果有多行汇编，则每一行都要加上 \"\\n\\t\"。其中的 “\\n” 是换行符，\"\\t” 是 tab 符，在每条命令的 结束加这两个符号，是为了让 gcc 把内联汇编代码翻译成一般的汇编代码时能够保证换行和留有一定的空格。对于基本asm语句，GCC编译出来的汇编代码就是双引号里的内容。例如： asm( \"pushl %eax\\n\\t\" \"movl $0,%eax\\n\\t\" \"popl %eax\" ); 实际上gcc在处理汇编时，是要把asm(...)的内容\"打印\"到汇编文件中，所以格式控制字符是必要的。再例如： asm(\"movl %eax, %ebx\"); asm(\"xorl %ebx, %edx\"); asm(\"movl $0, _boo); 在上面的例子中，由于我们在内联汇编中改变了 edx 和 ebx 的值，但是由于 gcc 的特殊的处理方法，即先形成汇编文件，再交给 GAS 去汇编，所以 GAS 并不知道我们已经改变了 edx和 ebx 的值，如果程序的上下文需要 edx 或 ebx 作其他内存单元或变量的暂存，就会产生没有预料的多次赋值，引起严重的后果。对于变量 _boo也存在一样的问题。为了解决这个问题，就要用到扩展 GCC 内联汇编语法。 GCC扩展内联汇编 使用GCC扩展内联汇编的例子如下： #define read_cr0() ({ \\ unsigned int __dummy; \\ __asm__( \\ \"movl %%cr0,%0\\n\\t\" \\ :\"=r\" (__dummy)); \\ __dummy; \\ }) 它代表什么含义呢？这需要从其基本格式讲起。GCC扩展内联汇编的基本格式是： asm [volatile] ( Assembler Template : Output Operands [ : Input Operands [ : Clobbers ] ]) 其中，asm 表示汇编代码的开始，其后可以跟 volatile（这是可选项），其含义是避免 “asm” 指令被删除、移动或组合，在执行代码时，如果不希望汇编语句被 gcc 优化而改变位置，就需要在 asm 符号后添加 volatile 关键词：asm volatile(...)；或者更详细地说明为：asm volatile(...)；然后就是小括弧，括弧中的内容是具体的内联汇编指令代码。 \"\" 为汇编指令部分，例如，\"movl %%cr0,%0\\n\\t\"。数字前加前缀 “％“，如％1，％2等表示使用寄存器的样板操作数。可以使用的操作数总数取决于具体CPU中通用寄存器的数 量，如Intel可以有8个。指令中有几个操作数，就说明有几个变量需要与寄存器结合，由gcc在编译时根据后面输出部分和输入部分的约束条件进行相应的处理。由于这些样板操作数的前缀使用了”％“，因此，在用到具体的寄存器时就在前面加两个“％”，如%%cr0。输出部分（output operand list），用以规定对输出变量（目标操作数）如何与寄存器结合的约束（constraint）,输出部分可以有多个约束，互相以逗号分开。每个约束以“＝”开头，接着用一个字母来表示操作数的类型，然后是关于变量结合的约束。例如，上例中： :\"=r\" (__dummy) “＝r”表示相应的目标操作数（指令部分的%0）可以使用任何一个通用寄存器，并且变量__dummy 存放在这个寄存器中，但如果是： :“＝m”(__dummy) “＝m”就表示相应的目标操作数是存放在内存单元__dummy中。表示约束条件的字母很多，下表给出几个主要的约束字母及其含义： 字母 含义 m, v, o 内存单元 R 任何通用寄存器 Q 寄存器eax, ebx, ecx,edx之一 I, h 直接操作数 E, F 浮点数 G 任意 a, b, c, d 寄存器eax/ax/al, ebx/bx/bl, ecx/cx/cl或edx/dx/dl S, D 寄存器esi或edi I 常数（0～31） 输入部分（input operand list）：输入部分与输出部分相似，但没有“＝”。如果输入部分一个操作数所要求使用的寄存器，与前面输出部分某个约束所要求的是同一个寄存器，那就把对应操作数的编号（如“1”，“2”等）放在约束条件中。在后面的例子中，可看到这种情况。修改部分（clobber list,也称 乱码列表）:这部分常常以“memory”为约束条件，以表示操作完成后内存中的内容已有改变，如果原来某个寄存器的内容来自内存，那么现在内存中这个单元的内容已经改变。乱码列表通知编译器，有些寄存器或内存因内联汇编块造成乱码，可隐式地破坏了条件寄存器的某些位（字段）。 注意，指令部分为必选项，而输入部分、输出部分及修改部分为可选项，当输入部分存在，而输出部分不存在时，冒号“：”要保留，当“memory”存在时，三个冒号都要保留，例如 #define __cli() __asm__ __volatile__(\"cli\": : :\"memory\") 下面是一个例子： int count=1; int value=1; int buf[10]; void main() { asm( \"cld \\n\\t\" \"rep \\n\\t\" \"stosl\" : : \"c\" (count), \"a\" (value) , \"D\" (buf) ); } 得到的主要汇编代码为： movl count,%ecx movl value,%eax movl buf,%edi #APP cld rep stosl #NO_APP cld,rep,stos这几条语句的功能是向buf中写上count个value值。冒号后的语句指明输入，输出和被改变的寄存器。通过冒号以后的语句，编译器就知道你的指令需要和改变哪些寄存器，从而可以优化寄存器的分配。其中符号\"c\"(count)指示要把count的值放入ecx寄存器。类似的还有： a eax b ebx c ecx d edx S esi D edi I 常数值，(0 - 31) q,r 动态分配的寄存器 g eax,ebx,ecx,edx或内存变量 A 把eax和edx合成一个64位的寄存器(use long longs) 也可以让gcc自己选择合适的寄存器。如下面的例子： asm(\"leal (%1,%1,4),%0\" : \"=r\" (x) : \"0\" (x) ); 这段代码到的主要汇编代码为： movl x,%eax #APP leal (%eax,%eax,4),%eax #NO_APP movl %eax,x 几点说明： [1] 使用q指示编译器从eax, ebx, ecx, edx分配寄存器。 使用r指示编译器从eax, ebx, ecx, edx, esi, edi分配寄存器。 [2] 不必把编译器分配的寄存器放入改变的寄存器列表，因为寄存器已经记住了它们。 [3] \"=\"是标示输出寄存器，必须这样用。 [4] 数字%n的用法：数字表示的寄存器是按照出现和从左到右的顺序映射到用\"r\"或\"q\"请求的寄存器．如果要重用\"r\"或\"q\"请求的寄存器的话，就可以使用它们。 [5] 如果强制使用固定的寄存器的话，如不用%1，而用ebx，则： asm(\"leal (%%ebx,%%ebx,4),%0\" : \"=r\" (x) : \"0\" (x) ); [!NOTE|style:flat] 注意要使用两个%,因为一个%的语法已经被%n用掉了。 代码维护 make和Makefile 简介 GNU make(简称make)是一种代码维护工具，在大中型项目中，它将根据程序各个模块的更新情况，自动的维护和生成目标代码。 make命令执行时，需要一个 makefile （或Makefile）文件，以告诉make命令需要怎么样的去编译和链接程序。首先，我们用一个示例来说明makefile的书写规则。以便给大家一个感兴认识。这个示例来源于gnu的make使用手册，在这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个makefile来告诉make命令如何编译和链接这几个文件。我们的规则是： 如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。 如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。 只要我们的makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。 makefile的规则 在讲述这个makefile之前，还是让我们先来粗略地看一看makefile的规则。 target ... : prerequisites ... command ... ... target也就是一个目标文件，可以是object file，也可以是执行文件。还可以是一个标签（label）。prerequisites就是，要生成那个target所需要的文件或是目标。command也就是make需要执行的命令（任意的shell命令）。 这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在 command中。如果prerequisites中有一个以上的文件比target文件要新，那么command所定义的命令就会被执行。这就是makefile的规则。也就是makefile中最核心的内容。 Git Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与Github不一样哦，Git是工具，而GitHub是可以用Git进行管理的远程仓库。 代码层次 你目录中的文件是第一层 缓存区，每次add之后，当前目录中要追踪的文件会作为一个版本会存放在缓存区。注意不是所有的文件。一般一个文件生成之后，会标记为“未追踪”，但是否对其做版本管理还是要选择的。例如一些编译文件就没有必要追踪。对需要做版本管理的问件，用add添加，不需要的用clean删除。 本地仓库，每次commit之后，缓存区最新的版本就会存放在本地仓库。这里要提及一个HEAD的概念。HEAD是当前的版本指向，每次更新或者回退都会修改HEAD的指向，但对仓库中每一个版本并不会删除。所以即使回退到过去还是有机会回到现在的版本的。 远程仓库，每次push之后，会将本地仓库中HEAD所指向的版本存放到远程仓库 常用命令 命令 功能 git init 在本地的当前目录里初始化git仓库 git status 查看当前仓库的状态 git add -A 增加目录中所有的文件到缓存区 git add file 增加相应文件到缓存区 git commit -m \"信息\" 将缓存区中更改提交到本地仓库 git log 查看当前版本之前的提交记录 git reflog 查看HEAD的变更记录，包括回退 git branch -b branch_name 建立一个新的分支 git diff 查看当前文件与缓存区文件的差异 git checkout -- file 取消更改，将缓存区的文件提取覆盖当前文件 git reset --hard 版本号 回退到相应版本号，同样也可以回退到未来的版本号 git clean -xf 删除当前目录中所有未追踪的文件 git config --global core.quotepath false 处理中文文件名 与Github链接 首先我们认为你已经有一个github的账户。 然后我们要建立SSH链接。这是一种通讯的加密协议。我先在我的笔记本上计算一对公钥和私钥，将公钥存储在github中，这样本地就可以通过SSH与github展开加密通讯。 建立方法，输入命令 ssh-keygen -t rsa -C \"your_email@youremail.com\" //双引号里面是你的常用邮箱 输入之后要输入口令，可以不用输入直接按“enter”一路确认就可以了。然后在账户的根目录（/或者/home/你的账户名，具体取决于你执行上述命令时所采用的账户）查找隐藏目录.ssh/id_rsa.pub文件，将当中内容添加到github中。 这样你就可以通过SSH链接到github中了。但是github作为一个远程仓库，你可以链接这个仓库，并保持同步。但是你不能把本地仓库直接上传到github中去。所以你应该先在github中建立一个对应的仓库，然后再在本地建立一个仓库，将两者进行链接，再去写入文件执行版本管理。所用到的命令有 git remote add origin git@github.com:/.git git pull origin master //因为github建立仓库时会有readme.md文件，先要拷贝一份 git push -u origin master //将本地仓库链接到master分支上，你当然可以链接到其他分支 git push//上传你的本地仓库 还有一种方法不用分两地建库再去链接。你可以只在github上建库，然后clone到本地目录中。 git clone git@github.com:/.git VScode中使用 因为VScode是一个集成工具可以直接在VScode中使用Git，用VScode打开已经配置好的仓库，VScode就可以自动读取里面的内容，然后当进行修改后可以通过VScode直接commit与push。具体的操作可以参考该教程。 调试器:GDB 功能 gdb 是功能强大的调试程序，可完成如下的调试任务： 设置断点 监视程序变量的值 程序的单步(step in/step over)执行 显示/修改变量的值 显示/修改寄存器 查看程序的堆栈情况 远程调试 调试线程 在可以使用 gdb 调试程序之前，必须使用 -g 或 –ggdb编译选项编译源文件。运行 gdb 调试程序时通常使用如下的命令： gdb progname 在 gdb 提示符处键入help，将列出命令的分类，主要的分类有： aliases：命令别名 breakpoints：断点定义； data：数据查看； files：指定并查看文件； internals：维护命令； running：程序执行； stack：调用栈查看； status：状态查看； tracepoints：跟踪程序执行。 键入 help 后跟命令的分类名，可获得该类命令的详细清单。 常用命令 命令 功能 break FILENAME:NUM 在特定源文件特定行上设置断点 clear FILENAME:NUM 删除设置在特定源文件特定行上的断点 run 运行调试程序 step 单步执行调试程序，不会直接执行函数 next 单步执行调试程序，会直接执行函数 backtrace 显示所有的调用栈帧。该命令可用来显示函数的调用顺序 where continue 继续执行正在调试的程序 display EXPR 每次程序停止后显示表达式的值,表达式由程序定义的变量组成 file FILENAME 装载指定的可执行文件进行调试 help CMDNAME 显示指定调试命令的帮助信息 info break 显示当前断点列表，包括到达断点处的次数等 info files 显示被调试文件的详细信息 info func 显示被调试程序的所有函数名称 info prog 显示被调试程序的执行状态 info local 显示被调试程序当前函数中的局部变量信息 info var 显示被调试程序的所有全局和静态变量名称 kill 终止正在被调试的程序 list 显示被调试程序的源代码 quit 退出 gdb 窗口相关命令 用gdb查看源代码可以用list命令，但是这个不够灵活。可以使用\"layout src\"命令，或者按Ctrl-X再按A，就会出现一个窗口可以查看源代码。也可以用使用-tui参数，这样进入gdb里面后就能直接打开代码查看窗口。其他代码窗口相关命令： 命令 功能 info win 显示窗口的大小 layout next 切换到下一个布局模式 layout prev 切换到上一个布局模式 layout src 只显示源代码 layout asm 只显示汇编代码 layout split 显示源代码和汇编代码 layout regs 增加寄存器内容显示 focus cmd/src/asm/regs/next/prev 切换当前窗口 refresh 刷新所有窗口 tui reg next 显示下一组寄存器 tui reg system 显示系统寄存器 update 更新源代码窗口和当前执行点 winheight name +/- line 调整name窗口的高度 tabset nchar 设置tab为nchar个字符 示例 下面以一个有错误的例子程序来介绍gdb的使用： /*bugging.c*/ #include #include static char buff [256]; static char* string; int main () { printf (\"Please input a string: \"); gets (string); printf (\"\\nYour string is: %s\\n\", string); } 这个程序是接受用户的输入，然后将用户的输入打印出来。该程序使用了一个未经过初始化的字符串地址 string，因此，编译并运行之后，将出现 \"Segment Fault\"错误： $ gcc -o bugging -g bugging.c $ ./bugging Please input a string: asdf Segmentation fault (core dumped) 为了查找该程序中出现的问题，我们利用 gdb，并按如下的步骤进行： [1] 运行 “gdb bugging” ，加载 bugging 可执行文件； $gdb bugging [2] 执行装入的 bugging 命令； (gdb) run [3] 使用 where 命令查看程序出错的地方； (gdb) where [4] 利用 list 命令查看调用 gets 函数附近的代码； (gdb) list [5] 在 gdb 中，我们在第 11 行处设置断点，看看是否是在第11行出错； (gdb) break 11 [6] 程序重新运行到第 11 行处停止，这时程序正常，然后执行单步命令next； (gdb) next [7] 程序确实出错，能够导致 gets 函数出错的因素就是变量 string。重新执行测试程，用 print 命令查看 string 的值； (gdb) run (gdb) print string (gdb) $1=0x0 [8] 问题在于string指向的是一个无效指针，修改程序，在10行和11行之间增加一条语句 “string=buff; ”，重新编译程序，然后继续运行，将看到正确的程序运行结果。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-08 22:00:46 "},"Lab0/前导知识/了解硬件模拟器.html":{"url":"Lab0/前导知识/了解硬件模拟器.html","title":"了解硬件模拟器","keywords":"","body":"了解硬件模拟器 简介 我们有了操作系统的代码，那要在哪里去运行呢。我们当然可以像计算机组成原理一样去烧制一块RISC-v架构的开发板，然后去debug。虽然这样可以，但duck不必，使用模拟器会使我们的实验更加方便。模拟器就是在计算机上通过软件模拟一个RISC-v架构的硬件平台，从而能够运行RISC-v的目标代码。 模拟器有很多，但我们为了方便，选择的是QEMU模拟器，的优点在于，内置了一套OpenSBI固件的实现，可以简化我们的代码。 常用命令 help 查看 qemu 帮助，显示所有支持的命令。 q\\ quit\\ exit 退出 qemu。 stop 停止 qemu。 c\\ cont\\ continue 连续执行。 x /fmt addr xp /fmt addr 显示内存内容，其中 'x' 为虚地址，'xp' 为实地址。 参数 /fmt i 表示反汇编，缺省参数为前一次参数。 p\\ print' 计算表达式值并显示，例如 $reg 表示寄存器结果。 memsave addr size file pmemsave addr size file 将内存保存到文件，memsave 为虚地址，pmemsave 为实地址。 breakpoint 相关： 设置、查看以及删除 breakpoint，pc执行到 breakpoint，qemu 停止。（暂时没有此功能） watchpoint 相关： 设置、查看以及删除 watchpoint, 当 watchpoint 地址内容被修改，停止。（暂时没有此功能） s\\ step 单步一条指令，能够跳过断点执行。 r\\ registers 显示全部寄存器内容。 info 相关操作 查询 qemu 支持的关于系统状态信息的操作。 其他具体的命令格式以及说明，参见 qemu help 命令帮助。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-08 21:06:46 "},"Lab0/配置环境.html":{"url":"Lab0/配置环境.html","title":"配置环境","keywords":"","body":"配置环境 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:08:24 "},"Lab0/配置环境/安装虚拟环境.html":{"url":"Lab0/配置环境/安装虚拟环境.html","title":"安装虚拟环境","keywords":"","body":"安装虚拟环境 安装Ubuntu 首先下载并安装VMware15 客户端（VMware只支持Windows与Linux，MAC需要自己上网查找虚拟机安装教程）。 到清华镜像站下载Ubuntu 18.04.3 的镜像文件。 具体的安装步骤可参考这个教程。 [!NOTE|style:flat] 不建议大家使用最新版的Ubuntu系统哦，因为可能会有一些玄学问题。 记得根据【了解实验环境】里面的配置升级源哦。 安装小工具 aptitude sudo apt get install aptitude 这个工具是安装软件的一个工具，可以自己解决包依赖问题，之后安装可以直接使用sudo aptitude install $APP($APP 为要安装的软件名字) gnome-tweaks sudo aptitude install gnome-tweaks 有的同学可能会感觉Ubuntu的字体太小，可以安装gnome-tweaks，来调整哦。具体的使用方法，自己研究哈。 搜狗输入法 默认的Ubuntu调中文还是比较麻烦，可以到搜狗输入法官网下载。 v2rayL 在某些时候，我们不得已需要科学上网的时候，可以使用一些工具，Windows的工具很多，但Linux的工具很少，可以前往这里下载一个工具。具体的安装步骤自行领会。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-08 23:02:54 "},"Lab0/配置环境/安装开发工具.html":{"url":"Lab0/配置环境/安装开发工具.html","title":"安装开发工具","keywords":"","body":"安装开发工具 设置环境变量 方便起见，可以先在终端里设置一个叫做RISCV的环境变量(在bash命令里可以通过$RISCV使用)，作为你安装所有和riscv有关的软件的路径。在/etc/profile里面写一行export RISCV=/your/path/to/riscv之类的东西就行。后面安装的各个项目最好也放在上面的的路径里面。当然需要去创建这个文件夹。 最小的软件开发环境需要：能够编译程序，能够运行程序。开发操作系统这样的系统软件也不例外。 安装VScode 进入其官网进行下载安装即可，与Windows类似。 安装编译器 我们使用的计算机都是基于x86架构的。如何把程序编译到riscv64架构的汇编？这需要我们使用“目标语言为riscv64机器码的编译器”，在我们的电脑上进行交叉编译。 放心，这里不需要你自己写编译器。我们使用现有的riscv-gcc编译器即可。从https://github.com/riscv/riscv-gcc clone下来，然后在x86架构上编译riscv-gcc编译器为可执行的x86程序，就可以运行它，来把你的程序源代码编译成riscv架构的可执行文件了。这有点像绕口令，但只要有一点编译原理的基础就可以理解。不过，这个riscv-gcc仓库很大，而且自己编译工具链总是一件麻烦的事。 其实，没必要那么麻烦，我们大可以使用别人已经编译好的编译器的可执行文件，也就是所谓的预编译（prebuilt）工具链，下载下来，放在你喜欢的地方（比如之前定义的$RISCV），配好路径（把编译器的位置加到系统的PATH环境变量里），就能在终端使用了。我们推荐使用sifive公司提供的预编译工具链，下载“GNU Embedded Toolchain ”。然后解压到之前的riscv文件夹下，把里面的bin文件夹加入到环境变量。 配置好后，在终端输入riscv64-unknown-elf-gcc -v查看安装的gcc版本, 如果输出一大堆东西且最后一行有gcc version 某个数字.某个数字.某个数字，说明gcc配置成功，否则需要检查一下哪里做错了，比如环境变量PATH配置是否正确。一般需要把一个形如..../bin的目录加到PATH里。 [!NOTE|style:flat] 可能有人会说，到底该怎么去做嘛，烦人，都没有写完。没有写完的，剩一点点的需要自己去查资料，自己实现哦~ Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-09 01:18:49 "},"Lab0/配置环境/安装依赖包.html":{"url":"Lab0/配置环境/安装依赖包.html","title":"安装依赖包","keywords":"","body":"安装依赖包 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:08:24 "},"Lab0/配置环境/安装硬件模拟器.html":{"url":"Lab0/配置环境/安装硬件模拟器.html","title":"安装硬件模拟器","keywords":"","body":"Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-09 01:18:38 "},"Lab0/配置环境/安装调试工具.html":{"url":"Lab0/配置环境/安装调试工具.html","title":"安装调试工具","keywords":"","body":"安装调试工具 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:08:24 "},"Lab0/附录.html":{"url":"Lab0/附录.html","title":"附录","keywords":"","body":"附录 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:08:24 "},"Lab0/准备知识.html":{"url":"Lab0/准备知识.html","title":"准备知识","keywords":"","body":"准备知识 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab0/了解OS实验.html":{"url":"Lab0/了解OS实验.html","title":"了解OS实验","keywords":"","body":"了解OS实验 写一个操作系统难吗？别被现在上百万行的Linux和Windows操作系统吓倒。当年Thompson趁他老婆带着小孩度假留他一人在家时，写了UNIX；当年Linus还是一个21岁大学生时完成了Linux雏形。站在这些巨人的肩膀上，我们能否也尝试一下做“巨人”的滋味呢？ MIT的Frans Kaashoek等在2006年参考PDP-11上的UNIX Version 6写了一个可在X86上跑的操作系统xv6（基于MIT License），用于学生学习操作系统。我们可以站在他们的肩膀上，基于xv6的设计，尝试着一步一步完成一个从“空空如也”到“五脏俱全”的“麻雀”操作系统——ucore，此“麻雀”包含虚存管理、进程管理、处理器调度、同步互斥、进程间通信、文件系统等主要内核功能，总的内核代码量（C+asm）不会超过5K行。充分体现了“小而全”的指导思想。 ucore的运行环境可以是真实的计算机（包括小型智能设备），不过考虑到调试和开发的方便，我们可采用硬件模拟器，比如QEMU、BOCHS、VirtualBox、VMware Player等。。ucore的开发环境主要是GCC中的gcc、gas、ld和MAKE等工具，在分析源代码上，可以采用Scitools提供的understand软件（跨平台）、VSCode（跨平台），windows环境上的source insight软件，或者基于emacs+ctags，vim+ctags等，都可以比较方便在在一堆文件中查找变量、函数定义、调用/访问关系等。软件开发的版本管理可以采用GIT、SVN等。比较文件和目录的不同可发现不同实验中的差异性和进行文件合并操作，可使用meld、kdiff3、UltraCompare等软件。调试（deubg）实验有助于发现设计中的错误，可采用gdb（配合qemu）等调试工具软件。并可整个实验的运行环境和开发环境在Linux环境中使用。 那我们准备如何一步一步来实现ucore呢？根据一个操作系统的设计实现过程，我们可以有如下的实验步骤： 启动操作系统的bootloader：OpenSBI。了解操作系统启动前的状态和要做的准备工作，了解运行操作系统的硬件支持，操作系统如何加载到内存中，理解两类中断--“外设中断”，“陷阱中断”等； 物理内存管理子系统。用于理解RISC-V分段/分页模式，了解操作系统如何管理物理内存； 虚拟内存管理子系统。通过页表机制和换入换出（swap）机制，以及中断-“故障中断”、缺页故障处理等，实现基于页的内存替换算法； 内核线程子系统。用于了解如何创建相对与用户进程更加简单的内核态线程，如果对内核线程进行动态管理等； 用户进程管理子系统。用于了解用户态进程创建、执行、切换和结束的动态管理过程，了解在用户态通过系统调用得到内核态的内核服务的过程； 处理器调度子系统。用于理解操作系统的调度过程和调度算法； 同步互斥与进程间通信子系统。了解进程间如何进行信息交换和共享，并了解同步互斥的具体实现以及对系统性能的影响，研究死锁产生的原因，以及如何避免死锁； 文件系统。了解文件系统的具体实现，与进程管理等的关系，了解缓存对操作系统IO访问的性能改进，了解虚拟文件系统（VFS）、buffer cache和disk driver之间的关系。 其中每个开发步骤都是建立在上一个步骤之上的，就像搭积木，从一个一个小木块，最终搭出来一个小房子。在搭房子的过程中，完成从理解操作系统原理到实践操作系统设计与实现的探索过程。这个房子最终的建筑架构和建设进度如下图所示： Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-16 16:12:49 "},"Lab0/设置实验环境.html":{"url":"Lab0/设置实验环境.html","title":"设置实验环境","keywords":"","body":"设置实验环境 我们参考了MIT的xv6、Harvard的OS161和Linux等设计了ucore OS实验，所有OS实验需在Linux下运行。对于经验不足的同学，推荐参考“通过虚拟机使用Linux实验环境”一节用虚拟机方式进行试验。 [!NOTE|style:flat] 也有同学在MAC系统和Windows系统中搭建实验环境，不过过程相对比较复杂，这里就不展开介绍了。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 12:44:02 "},"Lab0/开发OS实验的简单步骤.html":{"url":"Lab0/开发OS实验的简单步骤.html","title":"开发OS实验的简单步骤","keywords":"","body":"开发OS实验的简单步骤 本次OS实验大致可以通过如下过程就可以完成使用： 学习相关理论知识 建立LAB实验环境，采用VMware虚拟机的最简单方式完成 阅读本LAB实验指导书，了解实验要求 下载源码 进入各个OS实验工程目录 例如：cd labcodes/lab1 根据实验要求阅读并修改代码 编译源码 例如执行：make 如果不通过则返回步骤3 如果实现不正确（即看到步骤6的输出存在不是OK的情况）则返回3 如果实现基本正确（即看到6的输出都是OK）则push到自己github仓库 编写实验报告，发送到助教邮箱，并push到github仓库 另外，可以通过make qemu让OS实验工程在qemu上运行；可以通过make debug或make debug-nox命令实现通过gdb远程调试 OS实验工程。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-29 11:42:12 "},"Lab0/通过虚拟机使用Linux实验环境.html":{"url":"Lab0/通过虚拟机使用Linux实验环境.html","title":"通过虚拟机使用Linux实验环境","keywords":"","body":"通过虚拟机使用Linux实验环境 通过虚拟机进行实验是最容易的实验环境安装方法，这也是最简单的一种通过虚拟机方式使用Linux并完成OS各个实验的方法。具体步骤如下： 首先下载并安装VMware15 客户端（VMware只支持Windows与Linux，MAC需要自己上网查找虚拟机安装教程）。 到清华镜像站下载Ubuntu 18.04.3 的镜像文件。 具体的安装步骤可参考这个教程。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-08 21:09:47 "},"Lab0/安装使用Linux实验环境.html":{"url":"Lab0/安装使用Linux实验环境.html","title":"安装使用Linux实验环境","keywords":"","body":"安装使用Linux实验环境 使用Linux 在实验过程中，我们需要了解基于命令行方式的编译、调试、运行操作系统的实验方法。为此，需要了解基本的Linux命令行使用。 命令模式的基本结构和概念 Ubuntu是图形界面友好和易操作的linux发行版，但有时只需执行几条简单的指令就可以完成繁琐的鼠标点击才能完成的操作。linux的命令行操作模式功能可以实现你需要的所有操作。简单的说，命令行就是基于字符命令的用户界面，也被称为文本操作模式。绝大多数情况下， 用户通过输入一行或多行命令直接与计算机互动，来实现对计算机的操作。 如何进入命令模式 假设使用默认的图形界面为GNOME的任意版本Ubuntu Linux。点击鼠标右键->终端，就可以启动名为terminal程序，从而可以在此软件界面中进行命令行操作。 打开terminal程序后你首先可能会注意到类似下面的界面： kelee@ubuntu:~$ 你所看到的这些被称为命令终端提示符，它表示计算机已就绪，正在等待着用户输入操作指令。以我的屏幕画面为例，“kelee\"是当前所登录的用户名，“ubuntu”是这台计算机的主机名，“~”表示当前目录。此时输入任何指令按回车之后该指令将会提交到计算机运行，比如你可以输入命令：ls 再按下回车： ls [ENTER] 注意：[ENTER]是指输入完ls后按下回车键，而不是叫你输入这个单词，ls这个命令将会列出你当前所在目录里的所有文件和子目录列表。 下面介绍bash shell程序的基本使用方法，它是ubuntu缺省的外壳程序。 常用指令 查询文件列表：(ls) kelee@ubuntu:~$ ls Desktop Downloads Music Public Templates Documents examples.desktop Pictures riscv Videos ls命令默认状态下将按首字母升序列出你当前文件夹下面的所有内容，但这样直接运行所得到的信息也是比较少的，通常它可以结合以下这些参数运行以查询更多的信息： ls / # 将列出根目录'/'下的文件清单.如果给定一个参数，则命令行会把该参数当作命令行的工作目录。换句话说，命令行不再以当前目录为工作目录。 ls -l # 将给你列出一个更详细的文件清单. ls -a # 将列出包括隐藏文件(以.开头的文件)在内的所有文 件. ]ls -h # 将以KB/MB/GB的形式给出文件大小,而不是以纯粹的Bytes. 查询当前所在目录：(pwd) kelee@ubuntu:~$ pwd /home/kelee 进入其他目录：(cd) kelee@ubuntu:~$ cd riscv kelee@ubuntu:~/riscv$ pwd /home/kelee/riscv kelee@ubuntu:~/riscv$ 上面例子中，当前目录原来是/home/kelee,执行cd riscv之后再运行pwd可以发现，当前目录已经改为/riscv了。 在屏幕上输出字符： (echo) kelee@ubuntu:~$ echo \"Hello World\" Hello World 这是一个很有用的命令，它可以在屏幕上输入你指定的参数(\"\"号中的内容)，当然这里举的这个例子中它没有多大的实际意义，但随着你对LINUX指令的不断深入，就会发现它的价值所在。 显示文件内容：cat kelee@ubuntu:~$ cat tempfile.txt Roses are red. Violets are blue, and you have the bird-flue! 也可以使用less或more来显示比较大的文本文件内容。 复制文件： cp kelee@ubuntu:~$ cp tempfile.txt tempfile_copy.txt kelee@ubuntu:~$ cat tempfile_copy.txt Roses are red. Violets are blue, and you have the bird-flue! 移动文件：mv kelee@ubuntu:~$ ls Desktop Downloads Music Public tempfile_copy.txt Templates Documents examples.desktop Pictures riscv tempfile.txt Videos kelee@ubuntu:~$ mv tempfile_copy.txt tempfile_mv.txt kelee@ubuntu:~$ ls Desktop Downloads Music Public tempfile_mv.txt Templates Documents examples.desktop Pictures riscv tempfile.txt Videos 注意：在命令操作时系统基本上不会给你什么提示，当然，绝大多数的命令可以通过加上一个参数-v来要求系统给出执行命令的反馈信息； kelee@ubuntu:~$ mv -v tempfile_mv.txt tempfile_mv_v.txt renamed 'tempfile_mv.txt' -> 'tempfile_mv_v.txt' 建立一个空文本文件：touch kelee@ubuntu:~$ ls Desktop Downloads Music Public tempfile_mv_v.txt Templates Documents examples.desktop Pictures riscv tempfile.txt Videos kelee@ubuntu:~$ touch file1.txt kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt Videos Documents file1.txt Public tempfile.txt Downloads Music riscv Templates 建立一个目录：mkdir kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt Videos Documents file1.txt Public tempfile.txt Downloads Music riscv Templates kelee@ubuntu:~$ mkdir test_dir kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt test_dir Documents file1.txt Public tempfile.txt Videos Downloads Music riscv Templates 删除文件/目录：rm kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt test_dir Documents file1.txt Public tempfile.txt Videos Downloads Music riscv Templates kelee@ubuntu:~$ rm tempfile_mv_v.txt kelee@ubuntu:~$ ls -p Desktop/ examples.desktop Pictures/ tempfile.txt Videos/ Documents/ file1.txt Public/ Templates/ Downloads/ Music/ riscv/ test_dir/ kelee@ubuntu:~$ rm test_dir rm: cannot remove 'test_dir': Is a directory kelee@ubuntu:~$ rm -R test_dir kelee@ubuntu:~$ ls Desktop Downloads file1.txt Pictures riscv Templates Documents examples.desktop Music Public tempfile.txt Videos 在上面的操作：首先我们通过ls命令查询可知当前目下有两个文件和一个文件夹； [1] 你可以用参数 -p来让系统显示某一项的类型，比如是文件/文件夹/快捷链接等等； [2] 接下来我们用rm -i尝试删除文件，-i参数是让系统在执行删除操作前输出一条确认提示；i(interactive)也就是交互性的意思； [3] 当我们尝试用上面的命令去删除一个文件夹时会得到错误的提示，因为删除文件夹必须使用-R(recursive,循环）参数 特别提示：在使用命令操作时，系统假设你很明确自己在做什么，它不会给你太多的提示，比如你执行rm -Rf /，它将会删除你硬盘上所有的东西，并且不会给你任何提示，所以，尽量在使用命令时加上-i的参数，以让系统在执行前进行一次确认，防止你干一些蠢事。如 果你觉得每次都要输入-i太麻烦，你可以执行以下的命令，让－i成为默认参数： alias rm='rm -i' 查询当前进程：ps kelee@ubuntu:~$ ps PID TTY TIME CMD 3356 pts/0 00:00:00 bash 3659 pts/0 00:00:00 ps 这条命令会例出你所启动的所有进程； ps -a #可以例出系统当前运行的所有进程，包括由其他用户启动的进程； ps auxww #是一条相当人性化的命令，它会例出除一些很特殊进程以外的所有进程，并会以一个高可读的形式显示结果，每一个进程都会有较为详细的解释； 基本命令的介绍就到此为止，你可以访问网络得到更加详细的Linux命令介绍。 控制流程 输入/输出 input用来读取你通过键盘（或其他标准输入设备）输入的信息，output用于在屏幕（或其他标准输出设备）上输出你指定的输出内容.另外还有一些标准的出错提示也是通过这个命令来实现的。通常在遇到操作错误时，系统会自动调用这个命令来输出标准错误提示； 我们能重定向命令中产生的输入和输出流的位置。 重定向 如果你想把命令产生的输出流指向一个文件而不是（默认的）终端，你可以使用如下的语句： kelee@ubuntu:~$ ls >file2.txt kelee@ubuntu:~$ cat file2.txt Desktop Documents Downloads examples.desktop file1.txt file2.txt Music Pictures Public riscv tempfile.txt Templates Videos 以上例子将创建文件file2.txt如果file2.txt不存在的话。注意：如果file2.txt已经存在，那么上面的命令将复盖文件的内容。如果你想将内容添加到已存在的文件内容的最后，那你可以用下面这个语句： command >> filename 示例: kelee@ubuntu:~$ ls >>file2.txt kelee@ubuntu:~$ cat file2.txt Desktop Documents Downloads examples.desktop file1.txt file2.txt Music Pictures Public riscv tempfile.txt Templates Videos Desktop Documents Downloads examples.desktop file1.txt file2.txt Music Pictures Public riscv tempfile.txt Templates Videos 在这个例子中，你会发现原有的文件中添加了新的内容。接下来我们会见到另一种重定向方式：我们将把一个文件的内容作为将要执行的命令的输入。以下是这个语句： command 示例: kelee@ubuntu:~$ sort 管道 Linux的强大之处在于它能把几个简单的命令联合成为复杂的功能，通过键盘上的管道符号'|' 完成。现在，我们来排序上面的\"grep\"命令： kelee@ubuntu:~$ grep -i 'D' result.txt kelee@ubuntu:~$ cat result.txt Desktop Desktop Documents Documents Downloads Downloads examples.desktop examples.desktop Videos Videos 搜索 file2.txt 中的d字母，将输出分类并写入分类文件到 result.txt 。 有时候用ls列出很多命令的时候很不方便 这时“｜”就充分利用到了 ls -l | less 慢慢看吧. 后台进程 CLI 不是系统的串行接口。您可以在执行其他命令时给出系统命令。要启动一个进程到后台，追加一个“&”到命令后面。 sleep 60 & ls 睡眠命令在后台运行，您依然可以与计算机交互。除了不同步启动命令以外，最好把 '&' 理解成 ';'。 如果您有一个命令将占用很多时间，您想把它放入后台运行，也很简单。只要在命令运行时按下ctrl-z，它就会停止。然后键入 bg使其转入后台。fg 命令可使其转回前台。 sleep 60 # 这表示敲入Ctrl+Z键 bg fg 最后，您可以使用 ctrl-c 来杀死一个前台进程。 环境变量 特殊变量。PATH, PS1, ... 不显示中文 可通过执行如下命令避免显示乱码中文。在一个shell中，执行： export LANG=”” 这样在这个shell中，output信息缺省时英文。 获得软件包 命令行获取软件包 Ubuntu 下可以使用 apt-get 命令，apt-get 是一条 Linux 命令行命令，适用于 deb 包管理式的操作系统，主要用于自动从互联网软件库中搜索、安装、升级以及卸载软件或者操作系统。一般需要 root 执行权限，所以一般跟随 sudo 命令，如： sudo apt-get install gcc [ENTER] 常见的以及常用的 apt 命令有： apt-get install 下载 以及所依赖的软件包，同时进行软件包的安装或者升级。 apt-get remove 移除 以及所有依赖的软件包。 apt-cache search 搜索满足 的软件包。 apt-cache show/showpkg 显示软件包 的完整描述。 例如： kelee@ubuntu:~$ apt-cache search aptitude aptitude - terminal-based package manager aptitude-common - architecture independent files for the aptitude package manager aptitude-doc-en - English manual for aptitude, a terminal-based package manager libcwidget-dev - high-level terminal interface library for C++ (development files) apt-cacher - Caching proxy server for Debian/Ubuntu software repositories apticron - Simple tool to mail about pending package updates - cron version apticron-systemd - Simple tool to mail about pending package updates - systemd version aptitude-doc-cs - Czech manual for aptitude, a terminal-based package manager aptitude-doc-es - Spanish manual for aptitude, a terminal-based package manager aptitude-doc-fi - Finnish manual for aptitude, a terminal-based package manager aptitude-doc-fr - French manual for aptitude, a terminal-based package manager aptitude-doc-it - Italian manual for aptitude, a terminal-based package manager aptitude-doc-ja - Japanese manual for aptitude, a terminal-based package manager aptitude-doc-nl - Dutch manual for aptitude, a terminal-based package manager aptitude-doc-ru - Russian manual for aptitude, a terminal-based package manager aptitude-robot - Automate package choice management cron-apt - automatic update of packages using apt-get cupt - flexible package manager -- console interface gbrainy - brain teaser game and trainer to have fun and to keep your brain trained pkgsync - automated package list synchronization wajig - unified package management front-end for Debian kelee@ubuntu:~$ 配置升级源 Ubuntu的软件包获取依赖升级源，通过Software&Updates->Ubuntu Software->Download from:->Other:->China->mirrors.aliyun.com->Choose Server 查找帮助文件 Ubuntu 下提供 man 命令以完成帮助手册得查询。man 是 manual 的缩写，通过 man 命令可以对 Linux 下常用命令、安装软件、以及C语言常用函数等进行查询，获得相关帮助。 例如： kelee@ubuntu:~$ man printf PRINTF(1) User Commands PRINTF(1) NAME printf - format and print data SYNOPSIS printf FORMAT [ARGUMENT]... printf OPTION DESCRIPTION Print ARGUMENT(s) according to FORMAT, or execute according to OPTION: --help display this help and exit --version output version information and exit FORMAT controls the output as in C printf. Interpreted sequences are: \\\" double quote \\\\ backslash Manual page printf(1) line 1 (press h for help or q to quit) 通常可能会用到的帮助文件例如： gcc-doc cpp-doc glibc-doc 上述帮助文件可以通过 apt-get 命令或者软件包管理器获得。获得以后可以通过 man 命令进行命令或者参数查询。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-04 11:49:28 "},"Lab0/实验中可能使用的软件.html":{"url":"Lab0/实验中可能使用的软件.html","title":"实验中可能使用的软件","keywords":"","body":"实验中可能使用的软件 编辑器 自带的编辑器 Ubuntu 下自带的编辑器可以作为代码编辑的工具。例如 gedit 是 gnome 桌面环境下兼容UTF-8的文本编辑器。它十分的简单易用，有良好的语法高亮，对中文支持很好。通常可以通过双击或者命令行打开目标文件进行编辑。 Vim 编辑器 Vim是一款极方便的文本编辑软件，是UNIX下的同类型软件VI的改进版本。Vim经常被看作是“专门为程序员打造的文本编辑器”，功能强大且方便使用，便于进行程序开发。 Ubuntu 下默认安装的 vi 版本较低，功能较弱，建议在系统内安装或者升级到最新版本的 Vim。 关于Vim的常用命令以及使用，可以通过网络进行查找。 配置文件：Vim 的使用需要配置文件进行设置，例如： set nocompatible set encoding=utf-8 set fileencodings=utf-8,chinese set tabstop=4 set cindent shiftwidth=4 set backspace=indent,eol,start autocmd Filetype c set omnifunc=ccomplete#Complete autocmd Filetype cpp set omnifunc=cppcomplete#Complete set incsearch set number set display=lastline set ignorecase syntax on set nobackup set ruler set showcmd set smartindent set hlsearch set cmdheight=1 set laststatus=2 set shortmess=atI set formatoptions=tcrqn set autoindent 可以将上述配置文件保存到： ~/.vimrc 注意：.vimrc 默认情况下隐藏不可见，可以在命令行中通过 “ls -a” 命令进行查看。如果 '~' 目录下不存在该文件，可以手动创建。修改该文件以后，重启 Vim 可以使配置生效。 VScode VScode是很好的项目管理、代码编译器工具，集成了git，并且可以安装各类插件支持各种语言，习惯使用visual studio的同学使用起来会非常习惯，具体的下载安装使用方法，可以参考该教程，值得说明的是，我们在编译的时候需要其他工具联合编译，因此可以仅仅把VScode当成没有感情的写代码工具，不由它来编译运行，编译运行交给终端。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-10 11:38:20 "},"Lab1/":{"url":"Lab1/","title":"LAB1","keywords":"","body":"Lab1 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab1/实验目的.html":{"url":"Lab1/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab1/实验内容.html":{"url":"Lab1/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab2/":{"url":"Lab2/","title":"LAB2","keywords":"","body":"Lab2 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab2/实验目的.html":{"url":"Lab2/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab2/实验内容.html":{"url":"Lab2/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab3/":{"url":"Lab3/","title":"LAB3","keywords":"","body":"Lab3 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab3/实验目的.html":{"url":"Lab3/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab3/实验内容.html":{"url":"Lab3/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab4/":{"url":"Lab4/","title":"LAB4","keywords":"","body":"Lab4 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab4/实验目的.html":{"url":"Lab4/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab4/实验内容.html":{"url":"Lab4/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab5/":{"url":"Lab5/","title":"LAB5","keywords":"","body":"Lab5 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab5/实验目的.html":{"url":"Lab5/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab5/实验内容.html":{"url":"Lab5/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab6/":{"url":"Lab6/","title":"LAB6","keywords":"","body":"Lab6 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab6/实验目的.html":{"url":"Lab6/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab6/实验内容.html":{"url":"Lab6/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab7/":{"url":"Lab7/","title":"LAB7","keywords":"","body":"Lab7 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab7/实验目的.html":{"url":"Lab7/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab7/实验内容.html":{"url":"Lab7/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab8/":{"url":"Lab8/","title":"LAB8","keywords":"","body":"Lab8 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab8/实验目的.html":{"url":"Lab8/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab8/实验内容.html":{"url":"Lab8/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "}}