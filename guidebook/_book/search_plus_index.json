{"./":{"url":"./","title":"Introduction","keywords":"","body":"uCore OS(on RISC-V64)实验指导书 ucore实验指导书 ucore labs 1-8 源码和参考答案 实验总体流程 认真上操作系统的理论课程； 阅读ucore实验指导书，并参考其内容完成联系和实验报告; 在实验环境中完成实验并提交到自己的github上； 遇到问题，首先查询手册等其他资料，先自行解决； 如若不能解决，可在飞书群里提问，可以互相讨论，有助教老师答疑。 学习目标与对应手段 掌握OS基本概念：通过上课与学习教材，能理解OS原理与概念；阅读指导书并分析源码，能理解lab_codes_answer的labs运行结果。 掌握OS设计实现：在1的基础上，能够通过编程完成lab_codes的8个lab实验中的基本练习和实验报告。 掌握OS核心功能：在2的基础上，能够通过编程完成lab_codes的8个lab实验中的challenge练习。 掌握OS科学研究：联系老师，加入实验室，开始科研吧。 友情提示 课程铺垫——计算机组成原理、C语言、数据结构 工具掌握——命令行 shell、软件管理 apt-get/aptitude、版本管理 git/github、代码阅读 understand/VSCode、代码比较 diff/meld、开发编译调试 gcc/gdb/make、硬件模拟器 qemu、md文档编写 Typora 实验报告要求 独立完成； 用Markdown语言编写； 报告内容包括但不仅限于：实验目的、实验内容、实验步骤、实验结果、遇到的问题与解决方法； 报告编写完需按时发送给助教并上传到自己的github仓库里。 维护者 kelee@mail.nankai.edu.cn 如若对本指导书有任何疑问，请联系维护者！ Reference ucore step by step Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-12 18:07:18 "},"Lab0/":{"url":"Lab0/","title":"LAB0：ready~go!","keywords":"","body":"LAB0： ready~go! 学习与操作系统实验相关的前导知识，其主要包括实验环境、实验步骤、实验工具、uCore历史、RISC-V简介。 配置实验所需要的环境与软件。 [!NOTE|style:flat] 本次实验不需要撰写实验报告，但是需要自己设置好GitHub账号与自己的git连接。并且把自己的初始化后的仓库地址发送给助教老师。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-10 16:34:43 "},"Lab0/实验目的.html":{"url":"Lab0/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 了解操作系统开发实验环境 学会使用Ubuntu操作系统 熟悉命令行方式的编译、调试工程 掌握基于硬件模拟器的调试技术 学会使用基本的开发工具 掌握RISCV-32汇编语言 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:22:13 "},"Lab0/实验内容.html":{"url":"Lab0/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 阅读实验指导书内容以及涉及的官方文档或者教程。 对于实验指导书未涉及的内容能自行动手查询资料学习。 安装Ubuntu操作系统。 安装推荐的开发工具，若对某些工具情有独钟亦可。 安装依赖包、硬件模拟器、调试工具后尝试进行联合调试。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-11 16:56:26 "},"Lab0/前导知识.html":{"url":"Lab0/前导知识.html","title":"前导知识","keywords":"","body":"前导知识 该模块是LAB0的第一个模块，主要就是阅读学习相关的知识，对OS实验有一个基本的了解，看一下我们接下来一个学期到底要做什么，要实现什么样的一个东西，而这个东西又是基于什么基础慢慢搭建起来的。要搭建房子需要各种工具，工欲善其事必先利其器，所以要学会使用主要的开发调试工具，能让我们实验过程变得非常愉快。 最后由于我们是基于RISC-V指令集来完成实验，当然要掌握这门指令集的所有东西啦，幸运的是，你选择的是最简单的指令集，有没有开心一点呢？ [!NOTE|style:flat] 千万不要嫌接下来的前导知识杂没有用哦，答应我，一定要认认真真的看哈~ Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-09 23:21:42 "},"Lab0/前导知识/了解uCore.html":{"url":"Lab0/前导知识/了解uCore.html","title":"了解uCore","keywords":"","body":"了解uCore 2006年, MIT的Frans Kaashoek等人参考PDP-11上的UNIX Version 6写了一个可在x86指令集架构上运行的操作系统xv6（基于MIT License)。 2010年, 清华大学操作系统教学团队参考MIT的教学操作系统xv6, 开发了在x86指令集架构上运行的操作系统ucore, 多年来作为操作系统课程的实验框架使用, 已经成为了大家口中的\"祖传实验\". ucore麻雀虽小，五脏俱全。在不超过5k的代码量中包含虚拟内存管理、进程管理、处理器调度、同步互斥、进程间通信、文件系统等主要内核功能，充分体现了“小而全”的指导思想。 ucore的运行环境可以是真实的计算机（包括小型智能设备）。一开始ucore是运行在x86指令集架构上的，到了如今，x86指令集架构的问题渐渐开始暴露出来。 虽然在PC平台上占据绝对主流，但出于兼容性考虑x86架构仍然保留了许多的历史包袱，用于教学的时候总有些累赘。另一方面，为了更好的和目前5G、物联网技术的发展衔接，将ucore移植到RISC-V架构势在必行。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-16 11:19:34 "},"Lab0/前导知识/了解RISC-V.html":{"url":"Lab0/前导知识/了解RISC-V.html","title":"了解RISC-V","keywords":"","body":"了解RISC-V 发明 RISC发明者是美国加州大学伯克利分校教师David Patterson，RISC-V（拼做risk-five）是第五代精简指令集，也是由David Patterson指导的项目。2010年伯克利大学并行计算实验室(Par Lab) 的1位教授和2个研究生想要做一个项目，需要选一种计算机架构来做。当时面临的的是选择X86、ARM，还是其他指令集，不管选择哪个都或多或少有些问题，比如授权费价格高昂，不能开源，不能扩展更改等等。所以他们在2010年5月开始规划自己做一个新的、开源的指令集，就是RISC-V。 接着时间到2015年，这个指令集在学术界已经开始出名了，这时为了更好的推动这个指令集在技术和商业上的发展，3位创始人大佬做了下面两件事情。 技术方向，成立RISC-V基金会，维护指令集架构的完整性和非碎片化。 商业方向，成立SiFive公司，推动RISC-V的商业化。 基金会会员 目前加入RISC-V基金会的中国企业和机构有：阿里巴巴、华为、中科院计算所、华米科技、智芯科技、浪潮等。（具体会员名单可以在这里查看） 特点 设计哲学-简单就是美 无病一身轻——架构的篇幅。目前的“RISC-V架构文档”分为“指令集文档”（riscv-spec-v2.2.pdf）和“特权架构文档”（riscv-privileged-v1.10.pdf）。“指令集文档”的篇幅为145页，而“特权架构文档”的篇幅也仅为91页。熟悉体系结构的工程师仅需一至两天便可将其通读，虽然“RISC-V的手册”还在不断地丰富，但是相比“x86的架构文档”与“ARM的架构文档”，RISC-V的篇幅可以说是极其短小精悍。 [!NOTE|style:flat] 一定要仔细阅读《RISC-V手册》哦！！ 能屈能伸——模块化的指令集。RISC-V架构相比其他成熟的商业架构的最大一个不同还在于它是一个模块化的架构。因此，RISC-V架构不仅短小精悍，而且其不同的部分还能以模块化的方式组织在一起，从而试图通过一套统一的架构满足各种不同的应用。这种模块化是x86与ARM架构所不具备的。以ARM的架构为例，ARM的架构分为A、R和M三个系列，分别针对于Application（应用操作系统）、Real-Time（实时）和Embedded（嵌入式）三个领域，彼此之间并不兼容。模块化的RISC-V架构能够使得用户能够灵活选择不同的模块组合，以满足不同的应用场景，可以说是“老少咸宜” 浓缩的都是精华——指令的数量。短小精悍的架构以及模块化的哲学，使得RISC-V架构的指令数目非常的简洁。基本的RISC-V指令数目仅有40多条，加上其他的模块化扩展指令总共几十条指令。 指令集简介 模块化的指令子集。RISC-V的指令集使用模块化的方式进行组织，每一个模块使用一个英文字母来表示。RISC-V最基本也是唯一强制要求实现的指令集部分是由I字母表示的基本整数指令子集，使用该整数指令子集，便能够实现完整的软件编译器。其他的指令子集部分均为可选的模块，具有代表性的模块包括M/A/F/D/C。 规整的指令编码。RISC-V的指令集编码非常的规整，指令所需的通用寄存器的索引（Index）都被放在固定的位置。因此指令译码器（Instruction Decoder）可以非常便捷的译码出寄存器索引然后读取通用寄存器组（Register File，Regfile）。 优雅的压缩指令子集。基本的RISC-V基本整数指令子集（字母I表示 ）规定的指令长度均为等长的32位，这种等长指令定义使得仅支持整数指令子集的基本RISC-V CPU非常容易设计。但是等长的32位编码指令也会造成代码体积（Code Size）相对较大的问题。为了满足某些对于代码体积要求较高的场景（譬如嵌入式领域），RISC-V定义了一种可选的压缩（Compressed）指令子集，由字母C表示，也可以由RVC表示。RISC-V具有后发优势，从一开始便规划了压缩指令，预留了足够的编码空间，16位长指令与普通的32位长指令可以无缝自由地交织在一起，处理器也没有定义额外的状态。 特权模式。RISC-V架构定义了三种工作模式，又称特权模式（Privileged Mode）：Machine Mode：机器模式，简称M Mode。Supervisor Mode：监督模式，简称S Mode。User Mode：用户模式，简称U Mode。RISC-V架构定义M Mode为必选模式，另外两种为可选模式。通过不同的模式组合可以实现不同的系统。 自定制指令扩展。除了上述阐述的模块化指令子集的可扩展、可选择，RISC-V架构还有一个非常重要的特性，那就是支持第三方的扩展。用户可以扩展自己的指令子集，RISC-V预留了大量的指令编码空间用于用户的自定义扩展，同时，还定义了四条Custom指令可供用户直接使用，每条Custom指令都有几个比特位的子编码空间预留，因此，用户可以直接使用四条Custom指令扩展出几十条自定义的指令。 其他特点 可配置的通用寄存器组、简洁的存储器访问指令、高效的分支跳转指令、简洁的子程序调用、无条件码执行、无分支延迟槽、简洁的运算指令。 [!TIP|style:flat|label:友情链接] RISC-V基金会 中国开放指令生态（RISC-V）联盟 赛昉科技 终于有人把RISC-V讲明白了 什么是RISC-V Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-18 11:12:17 "},"Lab0/前导知识/了解OS实验.html":{"url":"Lab0/前导知识/了解OS实验.html","title":"了解OS实验","keywords":"","body":"了解OS实验 写一个操作系统难吗？别被现在上百万行的Linux和Windows操作系统吓倒。当年Thompson趁他老婆带着小孩度假留他一人在家时，写了UNIX；当年Linus还是一个21岁大学生时完成了Linux雏形。站在这些巨人的肩膀上，我们能否也尝试一下做“巨人”的滋味呢？ 实验内容 那我们准备如何一步一步来实现ucore呢？根据一个操作系统的设计实现过程，我们可以有如下的实验步骤： 启动操作系统的bootloader:OpenSBI。了解操作系统启动前的状态和要做的准备工作，了解运行操作系统的硬件支持，操作系统如何加载到内存中，理解两类中断--“外设中断”，“陷阱中断”等； 物理内存管理子系统。用于理解RISC-V分段/分页模式，了解操作系统如何管理物理内存； 虚拟内存管理子系统。通过页表机制和换入换出（swap）机制，以及中断-“故障中断”、缺页故障处理等，实现基于页的内存替换算法； 内核线程子系统。用于了解如何创建相对与用户进程更加简单的内核态线程，如果对内核线程进行动态管理等； 用户进程管理子系统。用于了解用户态进程创建、执行、切换和结束的动态管理过程，了解在用户态通过系统调用得到内核态的内核服务的过程； 处理器调度子系统。用于理解操作系统的调度过程和调度算法； 同步互斥与进程间通信子系统。了解进程间如何进行信息交换和共享，并了解同步互斥的具体实现以及对系统性能的影响，研究死锁产生的原因，以及如何避免死锁； 文件系统。了解文件系统的具体实现，与进程管理等的关系，了解缓存对操作系统IO访问的性能改进，了解虚拟文件系统（VFS）、buffer cache和disk driver之间的关系。 其中每个开发步骤都是建立在上一个步骤之上的，就像搭积木，从一个一个小木块，最终搭出来一个小房子。在搭房子的过程中，完成从理解操作系统原理到实践操作系统设计与实现的探索过程。这个房子最终的建筑架构和建设进度如下图所示： 开发OS实验的步骤 本次OS实验大致可以通过如下过程就可以完成使用： 学习相关理论知识 建立LAB实验环境，采用VMware虚拟机的最简单方式完成 阅读本LAB实验指导书，了解实验要求 下载源码 进入各个OS实验工程目录 例如：cd labcodes/lab1 根据实验要求阅读并修改代码 编译源码 例如执行：make 如果不通过则返回步骤3 如果实现不正确（即看到步骤6的输出存在不是OK的情况）则返回3 如果实现基本正确（即看到6的输出都是OK）则push到自己github仓库 编写实验报告，发送到助教邮箱，并push到github仓库 [!NOTE|style:flat] 可以通过make qemu让OS实验工程在qemu上运行；可以通过make debug或make debug-nox命令实现通过gdb远程调试 OS实验工程。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-18 10:46:31 "},"Lab0/前导知识/了解实验环境.html":{"url":"Lab0/前导知识/了解实验环境.html","title":"了解实验环境","keywords":"","body":"了解实验环境 在实验中，我们使用的系统环境是Ubuntu18.04。在实验过程中，我们需要了解基于命令行方式的编译、调试、运行操作系统的实验方法。为此，需要了解基本的Linux命令行使用。 [!TIP|style:flat] 当然现在只是了解一下，具体的操作还是要在安装好虚机以后再来哦~ 命令模式的基本结构和概念 Ubuntu是图形界面友好和易操作的Linux发行版，但有时只需执行几条简单的指令就可以完成繁琐的鼠标点击才能完成的操作。Linux的命令行操作模式功能可以实现你需要的所有操作。简单的说，命令行就是基于字符命令的用户界面，也被称为文本操作模式。绝大多数情况下， 用户通过输入一行或多行命令直接与计算机互动，来实现对计算机的操作。 如何进入命令模式 假设使用默认的图形界面为GNOME的任意版本Ubuntu Linux。点击鼠标右键->终端，就可以启动名为terminal程序，从而可以在此软件界面中进行命令行操作。 打开terminal程序后你首先可能会注意到类似下面的界面： kelee@ubuntu:~$ 你所看到的这些被称为命令终端提示符，它表示计算机已就绪，正在等待着用户输入操作指令。以我的屏幕画面为例，“kelee\"是当前所登录的用户名，“ubuntu”是这台计算机的主机名，“~”表示当前目录。此时输入任何指令按回车之后该指令将会提交到计算机运行，比如你可以输入命令：ls 再按下回车： ls [ENTER] 注意：[ENTER]是指输入完ls后按下回车键，而不是叫你输入这个单词，ls这个命令将会列出你当前所在目录里的所有文件和子目录列表。 下面介绍bash shell程序的基本使用方法，它是ubuntu缺省的外壳程序。 常用指令 查询文件列表：(ls) kelee@ubuntu:~$ ls Desktop Downloads Music Public Templates Documents examples.desktop Pictures riscv Videos ls命令默认状态下将按首字母升序列出你当前文件夹下面的所有内容，但这样直接运行所得到的信息也是比较少的，通常它可以结合以下这些参数运行以查询更多的信息： ls / # 将列出根目录'/'下的文件清单.如果给定一个参数，则命令行会把该参数当作命令行的工作目录。换句话说，命令行不再以当前目录为工作目录。 ls -l # 将给你列出一个更详细的文件清单. ls -a # 将列出包括隐藏文件(以.开头的文件)在内的所有文 件. ]ls -h # 将以KB/MB/GB的形式给出文件大小,而不是以纯粹的Bytes. 查询当前所在目录：(pwd) kelee@ubuntu:~$ pwd /home/kelee 进入其他目录：(cd) kelee@ubuntu:~$ cd riscv kelee@ubuntu:~/riscv$ pwd /home/kelee/riscv kelee@ubuntu:~/riscv$ 上面例子中，当前目录原来是/home/kelee,执行cd riscv之后再运行pwd可以发现，当前目录已经改为/riscv了。 在屏幕上输出字符： (echo) kelee@ubuntu:~$ echo \"Hello World\" Hello World 这是一个很有用的命令，它可以在屏幕上输入你指定的参数(\"\"号中的内容)，当然这里举的这个例子中它没有多大的实际意义，但随着你对LINUX指令的不断深入，就会发现它的价值所在。 显示文件内容：cat kelee@ubuntu:~$ cat tempfile.txt Roses are red. Violets are blue, and you have the bird-flue! 也可以使用less或more来显示比较大的文本文件内容。 复制文件： cp kelee@ubuntu:~$ cp tempfile.txt tempfile_copy.txt kelee@ubuntu:~$ cat tempfile_copy.txt Roses are red. Violets are blue, and you have the bird-flue! 移动文件：mv kelee@ubuntu:~$ ls Desktop Downloads Music Public tempfile_copy.txt Templates Documents examples.desktop Pictures riscv tempfile.txt Videos kelee@ubuntu:~$ mv tempfile_copy.txt tempfile_mv.txt kelee@ubuntu:~$ ls Desktop Downloads Music Public tempfile_mv.txt Templates Documents examples.desktop Pictures riscv tempfile.txt Videos 注意：在命令操作时系统基本上不会给你什么提示，当然，绝大多数的命令可以通过加上一个参数-v来要求系统给出执行命令的反馈信息； kelee@ubuntu:~$ mv -v tempfile_mv.txt tempfile_mv_v.txt renamed 'tempfile_mv.txt' -> 'tempfile_mv_v.txt' 建立一个空文本文件：touch kelee@ubuntu:~$ ls Desktop Downloads Music Public tempfile_mv_v.txt Templates Documents examples.desktop Pictures riscv tempfile.txt Videos kelee@ubuntu:~$ touch file1.txt kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt Videos Documents file1.txt Public tempfile.txt Downloads Music riscv Templates 建立一个目录：mkdir kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt Videos Documents file1.txt Public tempfile.txt Downloads Music riscv Templates kelee@ubuntu:~$ mkdir test_dir kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt test_dir Documents file1.txt Public tempfile.txt Videos Downloads Music riscv Templates 删除文件/目录：rm kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt test_dir Documents file1.txt Public tempfile.txt Videos Downloads Music riscv Templates kelee@ubuntu:~$ rm tempfile_mv_v.txt kelee@ubuntu:~$ ls -p Desktop/ examples.desktop Pictures/ tempfile.txt Videos/ Documents/ file1.txt Public/ Templates/ Downloads/ Music/ riscv/ test_dir/ kelee@ubuntu:~$ rm test_dir rm: cannot remove 'test_dir': Is a directory kelee@ubuntu:~$ rm -R test_dir kelee@ubuntu:~$ ls Desktop Downloads file1.txt Pictures riscv Templates Documents examples.desktop Music Public tempfile.txt Videos 在上面的操作：首先我们通过ls命令查询可知当前目下有两个文件和一个文件夹； [1] 你可以用参数 -p来让系统显示某一项的类型，比如是文件/文件夹/快捷链接等等； [2] 接下来我们用rm -i尝试删除文件，-i参数是让系统在执行删除操作前输出一条确认提示；i(interactive)也就是交互性的意思； [3] 当我们尝试用上面的命令去删除一个文件夹时会得到错误的提示，因为删除文件夹必须使用-R(recursive,循环）参数 特别提示：在使用命令操作时，系统假设你很明确自己在做什么，它不会给你太多的提示，比如你执行rm -Rf /，它将会删除你硬盘上所有的东西，并且不会给你任何提示，所以，尽量在使用命令时加上-i的参数，以让系统在执行前进行一次确认，防止你干一些蠢事。如 果你觉得每次都要输入-i太麻烦，你可以执行以下的命令，让－i成为默认参数： alias rm='rm -i' 查询当前进程：ps kelee@ubuntu:~$ ps PID TTY TIME CMD 3356 pts/0 00:00:00 bash 3659 pts/0 00:00:00 ps 这条命令会例出你所启动的所有进程； ps -a #可以例出系统当前运行的所有进程，包括由其他用户启动的进程； ps auxww #是一条相当人性化的命令，它会例出除一些很特殊进程以外的所有进程，并会以一个高可读的形式显示结果，每一个进程都会有较为详细的解释； 基本命令的介绍就到此为止，你可以访问网络得到更加详细的Linux命令介绍。 控制流程 输入/输出 input用来读取你通过键盘（或其他标准输入设备）输入的信息，output用于在屏幕（或其他标准输出设备）上输出你指定的输出内容.另外还有一些标准的出错提示也是通过这个命令来实现的。通常在遇到操作错误时，系统会自动调用这个命令来输出标准错误提示； 我们能重定向命令中产生的输入和输出流的位置。 重定向 如果你想把命令产生的输出流指向一个文件而不是（默认的）终端，你可以使用如下的语句： kelee@ubuntu:~$ ls >file2.txt kelee@ubuntu:~$ cat file2.txt Desktop Documents Downloads examples.desktop file1.txt file2.txt Music Pictures Public riscv tempfile.txt Templates Videos 以上例子将创建文件file2.txt如果file2.txt不存在的话。注意：如果file2.txt已经存在，那么上面的命令将复盖文件的内容。如果你想将内容添加到已存在的文件内容的最后，那你可以用下面这个语句： command >> filename 示例: kelee@ubuntu:~$ ls >>file2.txt kelee@ubuntu:~$ cat file2.txt Desktop Documents Downloads examples.desktop file1.txt file2.txt Music Pictures Public riscv tempfile.txt Templates Videos Desktop Documents Downloads examples.desktop file1.txt file2.txt Music Pictures Public riscv tempfile.txt Templates Videos 在这个例子中，你会发现原有的文件中添加了新的内容。接下来我们会见到另一种重定向方式：我们将把一个文件的内容作为将要执行的命令的输入。以下是这个语句： command 示例: kelee@ubuntu:~$ sort 管道 Linux的强大之处在于它能把几个简单的命令联合成为复杂的功能，通过键盘上的管道符号'|' 完成。现在，我们来排序上面的\"grep\"命令： kelee@ubuntu:~$ grep -i 'D' result.txt kelee@ubuntu:~$ cat result.txt Desktop Desktop Documents Documents Downloads Downloads examples.desktop examples.desktop Videos Videos 搜索 file2.txt 中的d字母，将输出分类并写入分类文件到 result.txt 。 有时候用ls列出很多命令的时候很不方便 这时“｜”就充分利用到了 ls -l | less 慢慢看吧. 后台进程 CLI 不是系统的串行接口。您可以在执行其他命令时给出系统命令。要启动一个进程到后台，追加一个“&”到命令后面。 sleep 60 & ls 睡眠命令在后台运行，您依然可以与计算机交互。除了不同步启动命令以外，最好把 '&' 理解成 ';'。 如果您有一个命令将占用很多时间，您想把它放入后台运行，也很简单。只要在命令运行时按下ctrl-z，它就会停止。然后键入 bg使其转入后台。fg 命令可使其转回前台。 sleep 60 # 这表示敲入Ctrl+Z键 bg fg 最后，您可以使用 ctrl-c 来杀死一个前台进程。 环境变量 特殊变量。PATH, PS1, ... 不显示中文 可通过执行如下命令避免显示乱码中文。在一个shell中，执行： export LANG=”” 这样在这个shell中，output信息缺省时英文。 获得软件包 命令行获取软件包 Ubuntu 下可以使用 apt-get 命令，apt-get 是一条 Linux 命令行命令，适用于 deb 包管理式的操作系统，主要用于自动从互联网软件库中搜索、安装、升级以及卸载软件或者操作系统。一般需要 root 执行权限，所以一般跟随 sudo 命令，如： sudo apt-get install gcc [ENTER] 常见的以及常用的 apt 命令有： apt-get install 下载 以及所依赖的软件包，同时进行软件包的安装或者升级。 apt-get remove 移除 以及所有依赖的软件包。 apt-cache search 搜索满足 的软件包。 apt-cache show/showpkg 显示软件包 的完整描述。 例如： kelee@ubuntu:~$ apt-cache search aptitude aptitude - terminal-based package manager aptitude-common - architecture independent files for the aptitude package manager aptitude-doc-en - English manual for aptitude, a terminal-based package manager libcwidget-dev - high-level terminal interface library for C++ (development files) apt-cacher - Caching proxy server for Debian/Ubuntu software repositories apticron - Simple tool to mail about pending package updates - cron version apticron-systemd - Simple tool to mail about pending package updates - systemd version aptitude-doc-cs - Czech manual for aptitude, a terminal-based package manager aptitude-doc-es - Spanish manual for aptitude, a terminal-based package manager aptitude-doc-fi - Finnish manual for aptitude, a terminal-based package manager aptitude-doc-fr - French manual for aptitude, a terminal-based package manager aptitude-doc-it - Italian manual for aptitude, a terminal-based package manager aptitude-doc-ja - Japanese manual for aptitude, a terminal-based package manager aptitude-doc-nl - Dutch manual for aptitude, a terminal-based package manager aptitude-doc-ru - Russian manual for aptitude, a terminal-based package manager aptitude-robot - Automate package choice management cron-apt - automatic update of packages using apt-get cupt - flexible package manager -- console interface gbrainy - brain teaser game and trainer to have fun and to keep your brain trained pkgsync - automated package list synchronization wajig - unified package management front-end for Debian kelee@ubuntu:~$ 配置升级源 Ubuntu的软件包获取依赖升级源，通过Software&Updates->Ubuntu Software->Download from:->Other:->China->mirrors.aliyun.com->Choose Server 查找帮助文件 Ubuntu 下提供 man 命令以完成帮助手册得查询。man 是 manual 的缩写，通过 man 命令可以对 Linux 下常用命令、安装软件、以及C语言常用函数等进行查询，获得相关帮助。 例如： kelee@ubuntu:~$ man printf PRINTF(1) User Commands PRINTF(1) NAME printf - format and print data SYNOPSIS printf FORMAT [ARGUMENT]... printf OPTION DESCRIPTION Print ARGUMENT(s) according to FORMAT, or execute according to OPTION: --help display this help and exit --version output version information and exit FORMAT controls the output as in C printf. Interpreted sequences are: \\\" double quote \\\\ backslash Manual page printf(1) line 1 (press h for help or q to quit) 通常可能会用到的帮助文件例如： gcc-doc cpp-doc glibc-doc 上述帮助文件可以通过 apt-get 命令或者软件包管理器获得。获得以后可以通过 man 命令进行命令或者参数查询。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-18 11:30:03 "},"Lab0/前导知识/了解开发调试基本工具.html":{"url":"Lab0/前导知识/了解开发调试基本工具.html","title":"了解开发调试基本工具","keywords":"","body":"了解开发调试基本工具 编辑器 Understand 在OS实验网站上有Understand Windows版的资源。该软件是一个阅读代码的很好工具，可以可视化的看到各个函数之间的调用关系，可以很好的找到函数、变量的定义，具体的使用方法以及介绍可以参考该教程。但是就编辑代码来说，不建议使用Understand。 VScode VScode是很好的项目管理、代码编译器工具，集成了git，并且可以安装各类插件支持各种语言，习惯使用visual studio的同学使用起来会非常习惯，具体的下载安装使用方法，可以参考该教程，值得说明的是，我们在编译的时候需要其他工具联合编译，因此可以仅仅把VScode当成没有感情的写代码工具，不由它来编译运行，编译运行交给终端。 [!NOTE|style:flat] VScode 快捷键的使用在Windows和Ubuntu上有些不同哦~ 写完了代码别忘了格式化代码鸭~看起来好舒服的！ 编译器:GCC 在Ubuntu Linux中的C语言编程主要基于GNU C的语法，通过gcc来编译并生成最终执行文件。GNU汇编（assembler）采用的是AT&T汇编格式，Microsoft 汇编采用Intel格式。 编译简单的 C 程序 C 语言经典的入门例子是 Hello World，下面是一示例代码： #include int main(void) { printf(\"Hello, world!\\n\"); return 0; } 我们假定该代码存为文件‘hello.c’。要用 gcc 编译该文件，使用下面的命令： $ gcc -Wall hello.c -o hello 该命令将文件‘hello.c’中的代码编译为机器码并存储在可执行文件 ‘hello’中。机器码的文件名是通过 -o 选项指定的。该选项通常作为命令行中的最后一个参数。如果被省略，输出文件默认为 ‘a.out’。 注意到如果当前目录中与可执行文件重名的文件已经存在，它将被复盖。 选项 -Wall 开启编译器几乎所有常用的警告──强烈建议你始终使用该选项。编译器有很多其他的警告选项，但 -Wall 是最常用的。默认情况下GCC 不会产生任何警告信息。当编写 C 或 C++ 程序时编译器警告非常有助于检测程序存在的问题。 本例中，编译器使用了 -Wall 选项而没产生任何警告，因为示例程序是完全合法的。 要运行该程序，输入可执行文件的路径如下： $ ./hello Hello, world! 这将可执行文件载入内存，并使 CPU 开始执行其包含的指令。 路径 ./ 指代当前目录，因此 ./hello 载入并执行当前目录下的可执行文件 ‘hello’。 AT&T汇编基本语法 Ucore中用到的是AT&T格式的汇编，与Intel格式的汇编有一些不同。二者语法上主要有以下几个不同： * 寄存器命名原则 AT&T: %eax Intel: eax * 源/目的操作数顺序 AT&T: movl %eax, %ebx Intel: mov ebx, eax * 常数/立即数的格式　 AT&T: movl $_value, %ebx Intel: mov eax, _value 把value的地址放入eax寄存器 AT&T: movl $0xd00d, %ebx Intel: mov ebx, 0xd00d * 操作数长度标识 AT&T: movw %ax, %bx Intel: mov bx, ax * 寻址方式 AT&T: immed32(basepointer, indexpointer, indexscale) Intel: [basepointer + indexpointer × indexscale + imm32) 如果操作系统工作于保护模式下，用的是32位线性地址，所以在计算地址时不用考虑segment:offset的问题。上式中的地址应为： imm32 + basepointer + indexpointer × indexscale 下面是一些例子： * 直接寻址 AT&T: foo Intel: [foo] boo是一个全局变量。注意加上$是表示地址引用，不加是表示值引用。对于局部变量，可以通过堆栈指针引用。 * 寄存器间接寻址 AT&T: (%eax) Intel: [eax] * 变址寻址 AT&T: _variable(%eax) Intel: [eax + _variable] AT&T: _array( ,%eax, 4) Intel: [eax × 4 + _array] AT&T: _array(%ebx, %eax,8) Intel: [ebx + eax × 8 + _array] GCC基本内联汇编 GCC 提供了两内内联汇编语句（inline asm statements）：基本内联汇编语句（basic inline asm statement)和扩展内联汇编语句（extended inline asm statement）。GCC基本内联汇编很简单，一般是按照下面的格式： asm(\"statements\"); 例如： asm(\"nop\"); asm(\"cli\"); \"asm\" 和 \"asm\" 的含义是完全一样的。如果有多行汇编，则每一行都要加上 \"\\n\\t\"。其中的 “\\n” 是换行符，\"\\t” 是 tab 符，在每条命令的 结束加这两个符号，是为了让 gcc 把内联汇编代码翻译成一般的汇编代码时能够保证换行和留有一定的空格。对于基本asm语句，GCC编译出来的汇编代码就是双引号里的内容。例如： asm( \"pushl %eax\\n\\t\" \"movl $0,%eax\\n\\t\" \"popl %eax\" ); 实际上gcc在处理汇编时，是要把asm(...)的内容\"打印\"到汇编文件中，所以格式控制字符是必要的。再例如： asm(\"movl %eax, %ebx\"); asm(\"xorl %ebx, %edx\"); asm(\"movl $0, _boo); 在上面的例子中，由于我们在内联汇编中改变了 edx 和 ebx 的值，但是由于 gcc 的特殊的处理方法，即先形成汇编文件，再交给 GAS 去汇编，所以 GAS 并不知道我们已经改变了 edx和 ebx 的值，如果程序的上下文需要 edx 或 ebx 作其他内存单元或变量的暂存，就会产生没有预料的多次赋值，引起严重的后果。对于变量 _boo也存在一样的问题。为了解决这个问题，就要用到扩展 GCC 内联汇编语法。 GCC扩展内联汇编 使用GCC扩展内联汇编的例子如下： #define read_cr0() ({ \\ unsigned int __dummy; \\ __asm__( \\ \"movl %%cr0,%0\\n\\t\" \\ :\"=r\" (__dummy)); \\ __dummy; \\ }) 它代表什么含义呢？这需要从其基本格式讲起。GCC扩展内联汇编的基本格式是： asm [volatile] ( Assembler Template : Output Operands [ : Input Operands [ : Clobbers ] ]) 其中，asm 表示汇编代码的开始，其后可以跟 volatile（这是可选项），其含义是避免 “asm” 指令被删除、移动或组合，在执行代码时，如果不希望汇编语句被 gcc 优化而改变位置，就需要在 asm 符号后添加 volatile 关键词：asm volatile(...)；或者更详细地说明为：asm volatile(...)；然后就是小括弧，括弧中的内容是具体的内联汇编指令代码。 \"\" 为汇编指令部分，例如，\"movl %%cr0,%0\\n\\t\"。数字前加前缀 “％“，如％1，％2等表示使用寄存器的样板操作数。可以使用的操作数总数取决于具体CPU中通用寄存器的数 量，如Intel可以有8个。指令中有几个操作数，就说明有几个变量需要与寄存器结合，由gcc在编译时根据后面输出部分和输入部分的约束条件进行相应的处理。由于这些样板操作数的前缀使用了”％“，因此，在用到具体的寄存器时就在前面加两个“％”，如%%cr0。输出部分（output operand list），用以规定对输出变量（目标操作数）如何与寄存器结合的约束（constraint）,输出部分可以有多个约束，互相以逗号分开。每个约束以“＝”开头，接着用一个字母来表示操作数的类型，然后是关于变量结合的约束。例如，上例中： :\"=r\" (__dummy) “＝r”表示相应的目标操作数（指令部分的%0）可以使用任何一个通用寄存器，并且变量__dummy 存放在这个寄存器中，但如果是： :“＝m”(__dummy) “＝m”就表示相应的目标操作数是存放在内存单元__dummy中。表示约束条件的字母很多，下表给出几个主要的约束字母及其含义： 字母 含义 m, v, o 内存单元 R 任何通用寄存器 Q 寄存器eax, ebx, ecx,edx之一 I, h 直接操作数 E, F 浮点数 G 任意 a, b, c, d 寄存器eax/ax/al, ebx/bx/bl, ecx/cx/cl或edx/dx/dl S, D 寄存器esi或edi I 常数（0～31） 输入部分（input operand list）：输入部分与输出部分相似，但没有“＝”。如果输入部分一个操作数所要求使用的寄存器，与前面输出部分某个约束所要求的是同一个寄存器，那就把对应操作数的编号（如“1”，“2”等）放在约束条件中。在后面的例子中，可看到这种情况。修改部分（clobber list,也称 乱码列表）:这部分常常以“memory”为约束条件，以表示操作完成后内存中的内容已有改变，如果原来某个寄存器的内容来自内存，那么现在内存中这个单元的内容已经改变。乱码列表通知编译器，有些寄存器或内存因内联汇编块造成乱码，可隐式地破坏了条件寄存器的某些位（字段）。 注意，指令部分为必选项，而输入部分、输出部分及修改部分为可选项，当输入部分存在，而输出部分不存在时，冒号“：”要保留，当“memory”存在时，三个冒号都要保留，例如 #define __cli() __asm__ __volatile__(\"cli\": : :\"memory\") 下面是一个例子： int count=1; int value=1; int buf[10]; void main() { asm( \"cld \\n\\t\" \"rep \\n\\t\" \"stosl\" : : \"c\" (count), \"a\" (value) , \"D\" (buf) ); } 得到的主要汇编代码为： movl count,%ecx movl value,%eax movl buf,%edi #APP cld rep stosl #NO_APP cld,rep,stos这几条语句的功能是向buf中写上count个value值。冒号后的语句指明输入，输出和被改变的寄存器。通过冒号以后的语句，编译器就知道你的指令需要和改变哪些寄存器，从而可以优化寄存器的分配。其中符号\"c\"(count)指示要把count的值放入ecx寄存器。类似的还有： a eax b ebx c ecx d edx S esi D edi I 常数值，(0 - 31) q,r 动态分配的寄存器 g eax,ebx,ecx,edx或内存变量 A 把eax和edx合成一个64位的寄存器(use long longs) 也可以让gcc自己选择合适的寄存器。如下面的例子： asm(\"leal (%1,%1,4),%0\" : \"=r\" (x) : \"0\" (x) ); 这段代码到的主要汇编代码为： movl x,%eax #APP leal (%eax,%eax,4),%eax #NO_APP movl %eax,x 几点说明： [1] 使用q指示编译器从eax, ebx, ecx, edx分配寄存器。 使用r指示编译器从eax, ebx, ecx, edx, esi, edi分配寄存器。 [2] 不必把编译器分配的寄存器放入改变的寄存器列表，因为寄存器已经记住了它们。 [3] \"=\"是标示输出寄存器，必须这样用。 [4] 数字%n的用法：数字表示的寄存器是按照出现和从左到右的顺序映射到用\"r\"或\"q\"请求的寄存器．如果要重用\"r\"或\"q\"请求的寄存器的话，就可以使用它们。 [5] 如果强制使用固定的寄存器的话，如不用%1，而用ebx，则： asm(\"leal (%%ebx,%%ebx,4),%0\" : \"=r\" (x) : \"0\" (x) ); [!NOTE|style:flat] 注意要使用两个%,因为一个%的语法已经被%n用掉了。 代码维护 make和Makefile 简介 GNU make(简称make)是一种代码维护工具，在大中型项目中，它将根据程序各个模块的更新情况，自动的维护和生成目标代码。 make命令执行时，需要一个 makefile （或Makefile）文件，以告诉make命令需要怎么样的去编译和链接程序。首先，我们用一个示例来说明makefile的书写规则。以便给大家一个感兴认识。这个示例来源于gnu的make使用手册，在这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个makefile来告诉make命令如何编译和链接这几个文件。我们的规则是： 如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。 如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。 只要我们的makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。 makefile的规则 在讲述这个makefile之前，还是让我们先来粗略地看一看makefile的规则。 target ... : prerequisites ... command ... ... target也就是一个目标文件，可以是object file，也可以是执行文件。还可以是一个标签（label）。prerequisites就是，要生成那个target所需要的文件或是目标。command也就是make需要执行的命令（任意的shell命令）。 这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在 command中。如果prerequisites中有一个以上的文件比target文件要新，那么command所定义的命令就会被执行。这就是makefile的规则。也就是makefile中最核心的内容。 可以查看GNU手册，或者查看这份中文教程。 Git Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与Github不一样哦，Git是工具，而GitHub是可以用Git进行管理的远程仓库。 代码层次 你目录中的文件是第一层 缓存区，每次add之后，当前目录中要追踪的文件会作为一个版本会存放在缓存区。注意不是所有的文件。一般一个文件生成之后，会标记为“未追踪”，但是否对其做版本管理还是要选择的。例如一些编译文件就没有必要追踪。对需要做版本管理的问件，用add添加，不需要的用clean删除。 本地仓库，每次commit之后，缓存区最新的版本就会存放在本地仓库。这里要提及一个HEAD的概念。HEAD是当前的版本指向，每次更新或者回退都会修改HEAD的指向，但对仓库中每一个版本并不会删除。所以即使回退到过去还是有机会回到现在的版本的。 远程仓库，每次push之后，会将本地仓库中HEAD所指向的版本存放到远程仓库 常用命令 命令 功能 git init 在本地的当前目录里初始化git仓库 git status 查看当前仓库的状态 git add -A 增加目录中所有的文件到缓存区 git add file 增加相应文件到缓存区 git commit -m \"信息\" 将缓存区中更改提交到本地仓库 git log 查看当前版本之前的提交记录 git reflog 查看HEAD的变更记录，包括回退 git branch -b branch_name 建立一个新的分支 git diff 查看当前文件与缓存区文件的差异 git checkout -- file 取消更改，将缓存区的文件提取覆盖当前文件 git reset --hard 版本号 回退到相应版本号，同样也可以回退到未来的版本号 git clean -xf 删除当前目录中所有未追踪的文件 git config --global core.quotepath false 处理中文文件名 与Github链接 首先我们认为你已经有一个github的账户。 然后我们要建立SSH链接。这是一种通讯的加密协议。我先在我的笔记本上计算一对公钥和私钥，将公钥存储在github中，这样本地就可以通过SSH与github展开加密通讯。 建立方法，输入命令 ssh-keygen -t rsa -C \"your_email@youremail.com\" //双引号里面是你的常用邮箱 输入之后要输入口令，可以不用输入直接按“enter”一路确认就可以了。然后在账户的根目录（/或者/home/你的账户名，具体取决于你执行上述命令时所采用的账户）查找隐藏目录.ssh/id_rsa.pub文件，将当中内容添加到github中。 这样你就可以通过SSH链接到github中了。但是github作为一个远程仓库，你可以链接这个仓库，并保持同步。但是你不能把本地仓库直接上传到github中去。所以你应该先在github中建立一个对应的仓库，然后再在本地建立一个仓库，将两者进行链接，再去写入文件执行版本管理。所用到的命令有 git remote add origin git@github.com:/.git git pull origin master //因为github建立仓库时会有readme.md文件，先要拷贝一份 git push -u origin master //将本地仓库链接到master分支上，你当然可以链接到其他分支 git push//上传你的本地仓库 还有一种方法不用分两地建库再去链接。你可以只在github上建库，然后clone到本地目录中。 git clone git@github.com:/.git VScode中使用 因为VScode是一个集成工具可以直接在VScode中使用Git，用VScode打开已经配置好的仓库，VScode就可以自动读取里面的内容，然后当进行修改后可以通过VScode直接commit与push。具体的操作可以参考该教程。 调试器:GDB 功能 gdb 是功能强大的调试程序，可完成如下的调试任务： 设置断点 监视程序变量的值 程序的单步(step in/step over)执行 显示/修改变量的值 显示/修改寄存器 查看程序的堆栈情况 远程调试 调试线程 在可以使用 gdb 调试程序之前，必须使用 -g 或 –ggdb编译选项编译源文件。运行 gdb 调试程序时通常使用如下的命令： gdb progname 在 gdb 提示符处键入help，将列出命令的分类，主要的分类有： aliases：命令别名 breakpoints：断点定义； data：数据查看； files：指定并查看文件； internals：维护命令； running：程序执行； stack：调用栈查看； status：状态查看； tracepoints：跟踪程序执行。 键入 help 后跟命令的分类名，可获得该类命令的详细清单。 常用命令 命令 功能 break FILENAME:NUM 在特定源文件特定行上设置断点 clear FILENAME:NUM 删除设置在特定源文件特定行上的断点 run 运行调试程序 step 单步执行调试程序，不会直接执行函数 next 单步执行调试程序，会直接执行函数 backtrace 显示所有的调用栈帧。该命令可用来显示函数的调用顺序 where continue 继续执行正在调试的程序 display EXPR 每次程序停止后显示表达式的值,表达式由程序定义的变量组成 file FILENAME 装载指定的可执行文件进行调试 help CMDNAME 显示指定调试命令的帮助信息 info break 显示当前断点列表，包括到达断点处的次数等 info files 显示被调试文件的详细信息 info func 显示被调试程序的所有函数名称 info prog 显示被调试程序的执行状态 info local 显示被调试程序当前函数中的局部变量信息 info var 显示被调试程序的所有全局和静态变量名称 kill 终止正在被调试的程序 list 显示被调试程序的源代码 quit 退出 gdb 窗口相关命令 用gdb查看源代码可以用list命令，但是这个不够灵活。可以使用\"layout src\"命令，或者按Ctrl-X再按A，就会出现一个窗口可以查看源代码。也可以用使用-tui参数，这样进入gdb里面后就能直接打开代码查看窗口。其他代码窗口相关命令： 命令 功能 info win 显示窗口的大小 layout next 切换到下一个布局模式 layout prev 切换到上一个布局模式 layout src 只显示源代码 layout asm 只显示汇编代码 layout split 显示源代码和汇编代码 layout regs 增加寄存器内容显示 focus cmd/src/asm/regs/next/prev 切换当前窗口 refresh 刷新所有窗口 tui reg next 显示下一组寄存器 tui reg system 显示系统寄存器 update 更新源代码窗口和当前执行点 winheight name +/- line 调整name窗口的高度 tabset nchar 设置tab为nchar个字符 示例 下面以一个有错误的例子程序来介绍gdb的使用： /*bugging.c*/ #include #include static char buff [256]; static char* string; int main () { printf (\"Please input a string: \"); gets (string); printf (\"\\nYour string is: %s\\n\", string); } 这个程序是接受用户的输入，然后将用户的输入打印出来。该程序使用了一个未经过初始化的字符串地址 string，因此，编译并运行之后，将出现 \"Segment Fault\"错误： $ gcc -o bugging -g bugging.c $ ./bugging Please input a string: asdf Segmentation fault (core dumped) 为了查找该程序中出现的问题，我们利用 gdb，并按如下的步骤进行： [1] 运行 “gdb bugging” ，加载 bugging 可执行文件； $gdb bugging [2] 执行装入的 bugging 命令； (gdb) run [3] 使用 where 命令查看程序出错的地方； (gdb) where [4] 利用 list 命令查看调用 gets 函数附近的代码； (gdb) list [5] 在 gdb 中，我们在第 11 行处设置断点，看看是否是在第11行出错； (gdb) break 11 [6] 程序重新运行到第 11 行处停止，这时程序正常，然后执行单步命令next； (gdb) next [7] 程序确实出错，能够导致 gets 函数出错的因素就是变量 string。重新执行测试程，用 print 命令查看 string 的值； (gdb) run (gdb) print string (gdb) $1=0x0 [8] 问题在于string指向的是一个无效指针，修改程序，在10行和11行之间增加一条语句 “string=buff; ”，重新编译程序，然后继续运行，将看到正确的程序运行结果。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-11 15:47:44 "},"Lab0/前导知识/了解硬件模拟器.html":{"url":"Lab0/前导知识/了解硬件模拟器.html","title":"了解硬件模拟器","keywords":"","body":"了解硬件模拟器 简介 我们有了操作系统的代码，那要在哪里去运行呢。我们当然可以像计算机组成原理一样去烧制一块RISC-v架构的开发板，然后去debug。虽然这样可以，但duck不必，使用模拟器会使我们的实验更加方便。模拟器就是在计算机上通过软件模拟一个RISC-v架构的硬件平台，从而能够运行RISC-v的目标代码。 模拟器有很多，但我们为了方便，选择的是QEMU模拟器，的优点在于，内置了一套OpenSBI固件的实现，可以简化我们的代码。 常用命令 help 查看 qemu 帮助，显示所有支持的命令。 q、quit、exit 退出 qemu。 stop 停止 qemu。 c、cont、continue 连续执行。 x /fmt addr xp /fmt addr 显示内存内容，其中 'x' 为虚地址，'xp' 为实地址。 参数 /fmt i 表示反汇编，缺省参数为前一次参数。 p、print 计算表达式值并显示，例如 $reg 表示寄存器结果。 memsave addr size file pmemsave addr size file 将内存保存到文件，memsave 为虚地址，pmemsave 为实地址。 breakpoint 相关： 设置、查看以及删除 breakpoint，pc执行到 breakpoint，qemu 停止。（暂时没有此功能） watchpoint 相关： 设置、查看以及删除 watchpoint, 当 watchpoint 地址内容被修改，停止。（暂时没有此功能） s、step 单步一条指令，能够跳过断点执行。 r、registers 显示全部寄存器内容。 info 相关操作 查询 qemu 支持的关于系统状态信息的操作。 其他具体的命令格式以及说明，参见 qemu help 命令帮助。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-09 23:58:00 "},"Lab0/配置环境.html":{"url":"Lab0/配置环境.html","title":"配置环境","keywords":"","body":"配置环境 看了这么多理论知识，终于可以动手开始实验啦。相信经过大一的学习，很多同学都会明白环境的重要性。在这一模块我们需要实现以下东西。 安装好Ubuntu虚拟系统，当然也可以是双系统，但不建议哈。太麻烦了。大家伙对Ubuntu可能不太熟悉，所以指导了大家安装了一些小工具，能够让大家用起来舒服一些。 安装开发工具。这里大家就要小心啦，涉及到编译、运行的东西一定咬谨慎哦。 安装硬件模拟器。我们的系统是需要运行在RISC-v架构的计算机上的，但是可以用软件模拟，为什么要用硬件呢，成本还低。所以要安装好硬件模拟器噢~ 我们写出来的代码不一定立马是对的，所以需要调试工具与硬件模拟器一起来联合调试。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-09 23:16:18 "},"Lab0/配置环境/安装虚拟环境.html":{"url":"Lab0/配置环境/安装虚拟环境.html","title":"安装虚拟环境","keywords":"","body":"安装虚拟环境 安装Ubuntu 首先下载并安装VMware15 客户端（VMware只支持Windows与Linux，MAC需要自己上网查找虚拟机安装教程）。 到清华镜像站下载Ubuntu 18.04.3 的镜像文件。 具体的安装步骤可参考这个教程。 [!NOTE|style:flat] 不建议大家使用最新版的Ubuntu系统哦，因为可能会有一些玄学问题。 记得根据【了解实验环境】里面的配置升级源哦。 安装小工具 aptitude sudo apt get install aptitude 这个工具是安装软件的一个工具，可以自己解决包依赖问题，之后安装可以直接使用sudo aptitude install $APP($APP 为要安装的软件名字) gnome-tweaks sudo aptitude install gnome-tweaks 有的同学可能会感觉Ubuntu的字体太小，可以安装gnome-tweaks，来调整哦。具体的使用方法，自己研究哈。 搜狗输入法 默认的Ubuntu调中文还是比较麻烦，可以到搜狗输入法官网下载。 v2rayL 在某些时候，我们不得已需要科学上网的时候，可以使用一些工具，Windows的工具很多，但Linux的工具很少，可以前往这里下载一个工具。具体的安装步骤自行领会。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-08 23:02:54 "},"Lab0/配置环境/安装开发工具.html":{"url":"Lab0/配置环境/安装开发工具.html","title":"安装开发工具","keywords":"","body":"安装开发工具 设置环境变量 方便起见，可以先在终端里设置一个叫做RISCV的环境变量(在bash命令里可以通过$RISCV使用)，作为你安装所有和riscv有关的软件的路径。在/etc/profile里面写一行export RISCV=/your/path/to/riscv之类的东西就行。后面安装的各个项目最好也放在上面的的路径里面。当然需要去创建这个文件夹。 最小的软件开发环境需要：能够编译程序，能够运行程序。开发操作系统这样的系统软件也不例外。 安装VScode 进入其官网进行下载安装即可，与Windows类似。 安装git sudo aptitude install git git下载完后记得初始化噢~并且与自己的github连接起来。 安装编译器 我们使用的计算机都是基于x86架构的。如何把程序编译到riscv64架构的汇编？这需要我们使用“目标语言为riscv64机器码的编译器”，在我们的电脑上进行交叉编译。 放心，这里不需要你自己写编译器。我们使用现有的riscv-gcc编译器即可。从https://github.com/riscv/riscv-gcc clone下来，然后在x86架构上编译riscv-gcc编译器为可执行的x86程序，就可以运行它，来把你的程序源代码编译成riscv架构的可执行文件了。这有点像绕口令，但只要有一点编译原理的基础就可以理解。不过，这个riscv-gcc仓库很大，而且自己编译工具链总是一件麻烦的事。 其实，没必要那么麻烦，我们大可以使用别人已经编译好的编译器的可执行文件，也就是所谓的预编译（prebuilt）工具链，下载下来，放在你喜欢的地方（比如之前定义的$RISCV），配好路径（把编译器的位置加到系统的PATH环境变量里），就能在终端使用了。我们推荐使用sifive公司提供的预编译工具链，下载“GNU Embedded Toolchain ”。然后解压到之前的riscv文件夹下，把里面的bin文件夹加入到环境变量。修改完记得运行source /etc/profile噢。 配置好后，在终端输入riscv64-unknown-elf-gcc -v查看安装的gcc版本, 如果输出一大堆东西且最后一行有gcc version 某个数字.某个数字.某个数字，说明gcc配置成功，否则需要检查一下哪里做错了，比如环境变量PATH配置是否正确。一般需要把一个形如..../bin的目录加到PATH里。 [!NOTE|style:flat] 可能有人会说，到底该怎么去做嘛，烦人，都没有写完。没有写完的，剩一点点的需要自己去查资料，自己实现哦~ Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-10 16:31:14 "},"Lab0/配置环境/安装硬件模拟器.html":{"url":"Lab0/配置环境/安装硬件模拟器.html","title":"安装硬件模拟器","keywords":"","body":"安装硬件模拟器 下载安装QEMU 我们也像安装编译器一样，去sifive的官网下载Ubuntu系统的riscv-qemu，里面的很多设置都已经设置好了的。在下载完，然后解压到之前的riscv文件夹下，把里面的bin文件夹加入到环境变量。修改完记得重启虚机噢。（这次熟练多了吧~）。 使用OpenSBI 新版 Qemu 中内置了 OpenSBI 固件（firmware），它主要负责在操作系统运行前的硬件初始化和加载操作系统的功能。我们使用以下命令尝试运行一下： qemu-system-riscv64 --machine virt --nographic --bios default 如果成功的话，就可以看到。 OpenSBI v0.5 (Oct 9 2019 12:03:04) ____ _____ ____ _____ / __ \\ / ____| _ \\_ _| | | | |_ __ ___ _ __ | (___ | |_) || | | | | | '_ \\ / _ \\ '_ \\ \\___ \\| _ 可以看到我们已经在 qemu-system-riscv64 模拟的 virt machine 硬件上将 OpenSBI 这个固件 跑起来了。Qemu 可以使用 Ctrl+a 再按下 x 退出（注意要松开Ctrl再单独按x）。 如果无法正常使用 Qemu，可以尝试下面这个命令。 $ sudo sysctl vm.overcommit_memory=1 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-09 23:39:06 "},"Lab0/配置环境/安装调试工具.html":{"url":"Lab0/配置环境/安装调试工具.html","title":"安装调试工具","keywords":"","body":"安装调试工具 编译 其实说安装有点不准确，因为之前已经把GDB已经悄悄的装进了环境变量里。其实就是在我们安装编译器的时候我们只需要打开lab0的文件夹，然后打开终端，输入make，就可以进行编译了 $ make + cc kern/init/entry.S + cc kern/init/init.c + cc kern/libs/stdio.c + cc kern/driver/console.c + cc libs/string.c + cc libs/printfmt.c + cc libs/readline.c + cc libs/sbi.c + ld bin/kernel riscv64-unknown-elf-objcopy bin/kernel --strip-all -O binary bin/ucore.img 可以看到多了几个文件夹，我们之后再来介绍这些。 修改脚本 工具链（之前下载的编译器里面的工具）里提供了相应的gdb工具，要使用gdb，就需要对脚本进行修改。在源代码的文件夹中，找到lab0中的Makefile文件然后找到CC := $(GCCPREFIX)gcc在后面添加-g。 使用GDB进行调试 因为gdb和qemu是两个应用不能直接交流，比较常用的方法是以tcp进行通讯，也就是让qemu在localhost::1234端口上等待。 在lab0文件夹下打开终端，运行 $ qemu-system-riscv64 -S -s -hda ./bin/ucore.img WARNING: Image format was not specified for './bin/ucore.img' and probing guessed raw. Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted. Specify the 'raw' format explicitly to remove the restrictions. VNC server running on 127.0.0.1:5900xxxxxxxxxx qemu-system-riscv64 -S -s -hda ./bin/ucore.img$ qemu-system-riscv64 -S -s -hda ./bin/ucore.img WARNING: Image format was not specified for './bin/ucore.img' and probing guessed raw. Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted. Specify the 'raw' format explicitly to remove the restrictions.VNC server running on 127.0.0.1:5900 然后在该文件夹下重新打开一个终端，运行 $ riscv64-unknown-elf-gdb ./bin/kernel GNU gdb (SiFive GDB 8.3.0-2020.04.0) 8.3 Copyright (C) 2019 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"--host=x86_64-linux-gnu --target=riscv64-unknown-elf\". Type \"show configuration\" for configuration details. For bug reporting instructions, please see: . Find the GDB manual and other documentation resources online at: . For help, type \"help\". Type \"apropos word\" to search for commands related to \"word\"... Reading symbols from ./bin/kernel... (gdb) 接着连接qemu： (gdb) target remote :1234 Remote debugging using :1234 0x0000000000001000 in ?? () 连接成功输入si就可以进行运行下一条指令， (gdb) si 0x0000000000001004 in ?? () 这样就代表可以正常运行了噢，具体调试步骤与方法，看一下前面哈。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-10 16:10:59 "},"Lab0.5/":{"url":"Lab0.5/","title":"LAB0.5：最小可执行内核","keywords":"","body":"LAB0.5 相对于上百万行的现代操作系统(linux, windows), 几千行的ucore是一只\"麻雀\"。但这只麻雀依然是一只胖麻雀，我们一眼看不过来几千行的代码。所以，我们要再做简化，先用好刀法，片掉麻雀的血肉, 搞出一个\"麻雀骨架\"，看得通透，再像组装哪吒一样，把血肉安回去，变成一个活生生的麻雀。 lab0.5是lab1的预备，我们构建一个最小的可执行内核（”麻雀骨架“），它能够进行格式化的输出，然后进入死循环。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-11 14:34:48 "},"Lab0.5/实验目的.html":{"url":"Lab0.5/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 逐步掌握以下过程： 源码是如何被编译成可执行文件的。 编译成可执行文件后，计算机如何加载操作系统。 加载以后，该从哪里去运行操作系统。 操作系统的输出信息是怎么输出的呢。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-11 14:27:50 "},"Lab0.5/实验内容.html":{"url":"Lab0.5/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 跟着实验指导书的步伐，阅读框架代码。 结合框架代码，深刻理解RISC-v。 内核的内存布局和入口点设置 通过sbi封装好输入输出函数 借助bootloader:OpenSBI初始化OS，完成练习。 按要求撰写实验报告。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-11 14:39:16 "},"Lab0.5/练习.html":{"url":"Lab0.5/练习.html","title":"练习","keywords":"","body":"练习 练习1：理解通过make生成执行文件的过程 列出本实验各练习中对应的OS原理的知识点，并说明本实验中的实现部分如何对应和体现了原理中的基本概念和关键知识点。 在此练习中，大家需要通过静态分析代码来了解： lab0.5/Makefile，解释操作系统镜像文件ucore.img是如何一步一步生成的？ (需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果) 阅读分析lab0.5/tools/kernel.ld 链接脚本，给出其每行含义。 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？ [!TIP|style:flat] 查看linkscript、装载位置(base address)和对其地址(align)） 练习2： 分析OpenSBI加载bin格式的OS的过程 OpenSBI如何读取硬盘扇区的？ OpenSBI是如何加载bin格式的OS？ Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-11 17:03:09 "},"Lab0.5/内存布局.html":{"url":"Lab0.5/内存布局.html","title":"内存布局","keywords":"","body":"内存布局，OpenSBI，elf和bin 计算机组成 首先我们回顾计算机的组成: CPU, 存储设备（粗略地说，包括断电后遗失的内存，和断电后不遗失的硬盘），输入输出设备，总线。 现在我们手里的东西有：QEMU会帮助我们模拟一块riscv64的CPU，一块物理内存，还会借助你的电脑的键盘和显示屏来模拟命令行的输入和输出。虽然QEMU不会真正模拟一堆线缆，但是总线的通信功能也在QEMU内部实现了。 还差什么呢？硬盘。 OpenSBI 我们需要硬盘上的程序和数据。比如崭新的windows电脑里C盘已经被占据的二三十GB空间，除去预装的应用软件，还有一部分是windows操作系统的内核。在插上电源开机之后，就需要运行操作系统的内核，然后由操作系统来管理计算机。 问题在于，操作系统作为一个程序，必须加载到内存里才能执行。而“把操作系统加载到内存里”这件事情，不是操作系统自己能做到的，就好像你不能拽着头发把自己拽离地面。 因此我们可以想象，在操作系统执行之前，必然有一个其他程序执行，他作为“先锋队”，完成“把操作系统加载到内存“这个工作，然后他功成身退，把CPU的控制权交给操作系统。 这个“其他程序”，我们一般称之为bootloader. 很好理解：他负责boot(开机)，还负责load(加载OS到内存里)，所以叫bootloader. 在QEMU模拟的riscv计算机里，我们使用QEMU自带的bootloader: OpenSBI固件。 [!TIP|style:flat|label:知识点] 在计算机中，固件(firmware)是一种特定的计算机软件，它为设备的特定硬件提供低级控制，也可以进一步加载其他软件。固件可以为设备更复杂的软件（如操作系统）提供标准化的操作环境。对于不太复杂的设备，固件可以直接充当设备的完整操作系统，执行所有控制、监视和数据操作功能。 在基于 x86 的计算机系统中, BIOS 或 UEFI 是固件；在基于 riscv 的计算机系统中，OpenSBI 是固件。OpenSBI运行在M态（M-mode），因为固件需要直接访问硬件。 RISCV有四种特权级（privilege level）。 Level Encoding 全称 简称 0 00 User/Application U 1 01 Supervisor S 2 10 Reserved(目前未使用，保留) 3 11 Machine M 粗略的分类： U-mode是用户程序、应用程序的特权级，S-mode是操作系统内核的特权级，M-mode是固件的特权级。 详细内容请自行查阅RISC-v手册。 elf与bin 我们可以想象这样的过程：操作系统的二进制可执行文件被OpenSBI加载到内存中，然后OpenSBI会把CPU的\"当前指令指针\"(pc, program counter)跳转到内存里的一个位置，开始执行内存中那个位置的指令。 OpenSBI怎样知道把操作系统加载到内存的什么位置？总不能随便选个位置。也许你会觉得可以把操作系统的代码总是加载到固定的位置，比如总是加载到内存地址最高的地方。 问题在于，之后OpenSBI还要把CPU的program counter跳转到一个位置,开始操作系统的执行。如果加载操作系统到内存里的时候随便加载，那么OpenSBI怎么知道把program counter跳转到哪里去呢？难道操作系统的二进制可执行文件需要提供“program counter跳转到哪里\"这样的信息？ 实际上，操作系统的二进制可执行文件，会指定它自己应该被加载到内存的哪个地址。而OpenSBI会很听话地把二进制可执行文件放到她想去的位置上。但是关于program counter的跳转，OpenSBI是独断专行的，总是会把program counter跳到0x80200000这个内存地址开始执行, 所以故事(版本1)其实是这样的： OpenSBI: 操作系统， 你到0x8020000等着program counter跳过来执行！ 操作系统：好的！请把我加载到xxxxxx这个位置，这样program counter跳过来的时候就不会出问题了。 实际上，二进制程序加载到内存中是一件很精细的工作。一个二进制程序包括很多section, 如text(程序代码)，bss(需要初始化为零的数据)，rodata(只读数据)。二进制程序的每个section都可以指定一个希望被加载到的内存地址。 故事可以是这样的吗？（版本2） OpenSBI: 操作系统， 你到0x8020000等着program counter跳过来执行！ 操作系统：好的！请把我的text section加载到A位置，data section加载到B位置，rodata section加载到C位置......这样program counter跳过来的时候就不会出问题了！ OpenSBI: 你说啥？ 两个版本的故事是因为，我们有两种不同的可执行文件格式：elf(e是executable的意思， l是linkable的意思，f是format的意思)和bin(binary)。 elf文件(wikipedia: elf)比较复杂，包含一个文件头(ELF header), 包含冗余的调试信息，指定程序每个section的内存布局，需要解析program header才能知道各段(section)的信息。如果我们已经有一个完整的操作系统来解析elf文件，那么elf文件可以直接执行。但是对于OpenSBI来说，elf格式还是太复杂了，把操作系统内核的elf文件交给OpenSBI就会发生版本2的悲惨故事。 bin文件就比较简单了，简单地在文件头之后解释自己应该被加载到什么起始位置。OpenSBI可以理解得很清楚，这就是版本1的故事。 我们举一个例子解释elf和bin文件的区别：初始化为零的一个大数组，在elf文件里是bss数据段的一部分，只需要记住这个数组的起点和终点就可以了，等到加载到内存里的时候分配那一段内存。但是在bin文件里，那个数组有多大，有多少个字节的0，bin文件就要对应有多少个零。所以如果一个程序里声明了一个大全局数组（默认初始化为0），那么可能编译出来的elf文件只有几KB, 而生成bin文件之后却有几MB, 这是很正常的。实际上，可以认为bin文件会把elf文件指定的每段的内存布局都映射到一块线性的数据里，这块线性的数据（或者说程序）加载到内存里就符合elf文件之前指定的布局。 那么我们的任务就明确了：得到内存布局合适的elf文件，然后把它转化成bin文件（这一步通过objcopy实现），然后加载到QEMU里运行（QEMU自带的OpenSBI会干这个活）。下面我们来看如何设置elf文件的内存布局。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-11 14:51:50 "},"Lab0.5/链接脚本.html":{"url":"Lab0.5/链接脚本.html","title":"链接脚本","keywords":"","body":"链接脚本和入口点 gnu工具链中，包含一个链接器ld 如果你很好奇，可以看linker script的详细语法 链接器的作用是把输入文件(往往是 .o文件)链接成输出文件(往往是elf文件)。一般来说，输入文件和输出文件都有很多section, 链接脚本(linker script)的作用，就是描述怎样把输入文件的section映射到输出文件的section, 同时规定这些section的内存布局。 如果你不提供链接脚本，ld会使用默认的一个链接脚本，这个默认的链接脚本适合链接出一个能在现有操作系统下运行的应用程序，但是并不适合链接一个操作系统内核。你可以通过ld --verbose来查看默认的链接脚本。 [!NOTE|style:flat] 要打开代码看噢，这里没有哒！ 我们在链接脚本里把程序的入口点定义为kern_entry, 那么我们的程序里需要有一个名称为kern_entry的符号。我们在kern/init/entry.S编写了一段汇编代码, 作为整个内核的入口点。 #include #include .section .text,\"ax\",%progbits .globl kern_entry kern_entry: la sp, bootstacktop tail kern_init #调用kern_init, 这是我们要用C语言编写的一个函数, tail是riscv伪指令，作用相当于调用函数（跳转） .section .data # .align 2^12 .align PGSHIFT .global bootstack bootstack: .space KSTACKSIZE .global bootstacktop bootstacktop: 里面有很多符号和指令，定义的符号，应该知道去哪找吧（偷偷告诉你吧，在头文件呀！）。关于指令呢，就需要自己去查阅手册咯。如果看不懂汇编代码结构的，自己查资料噢~不要怀着疑惑往下做。会越来越懵。 诶诶，看到这，下一步该干嘛，该去找哪个呢，想一想噢。 哎鸭！调用了唯一的一个函数，当然是去找函数啦。这个函数在干嘛呢？不好奇么。那就往下看。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-11 15:23:36 "},"Lab0.5/真正的入口点.html":{"url":"Lab0.5/真正的入口点.html","title":"真正的入口点","keywords":"","body":"“真正的“入口点 我们在kern/init/init.c编写函数kern_init, 作为“真正的”内核入口点。为了让我们能看到一些效果，我们希望它能在命令行进行格式化输出。 如果我们在linux下运行一个C程序，需要格式化输出，那么大一学生都知道我们应该#include。于是我们在kern/init/init.c也这么写一句。且慢！linux下，当我们调用C语言标准库的函数时，实际上依赖于glibc提供的运行时环境，也就是一定程度上依赖于操作系统提供的支持。可是我们并没有把glibc移植到ucore里！ 怎么办呢？只能自己动手，丰衣足食。QEMU里的OpenSBI固件提供了输入一个字符和输出一个字符的接口，我们一会把这个接口一层层封装起来，提供stdio.h里的格式化输出函数cprintf()来使用。这里格式化输出函数的名字不使用原先的printf()，强调这是我们在ucore里重新实现的函数。 接下来就去看看，我们是怎么从OpenSBI的接口一层层封装到格式化输入输出函数的。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-11 15:29:01 "},"Lab0.5/从SBI到stdio.html":{"url":"Lab0.5/从SBI到stdio.html","title":"从SBI到stdio","keywords":"","body":"从SBI到stdio OpenSBI作为运行在M态的软件（或者说固件）, 提供了一些接口供我们编写内核的时候使用。 我们可以通过ecall指令(environment call)调用OpenSBI。通过寄存器传递给OpenSBI一个”调用编号“，如果编号在 0-8 之间，则由OpenSBI进行处理，否则交由我们自己的中断处理程序处理（暂未实现）。有时OpenSBI调用需要像函数调用一样传递参数，这里传递参数的方式也和函数调用一样，按照riscv的函数调用约定(calling convention)把参数放到寄存器里。可以阅读SBI的详细文档。 [!TIP|style:flat|label:知识点] ecall(environment call)，当我们在 S 态执行这条指令时，会触发一个 ecall-from-s-mode-exception，从而进入 M 模式中的中断处理流程（如设置定时器等）；当我们在 U 态执行这条指令时，会触发一个 ecall-from-u-mode-exception，从而进入 S 模式中的中断处理流程（常用来进行系统调用）。 关于这个，大三的时候会被好好折磨的噢【坏笑】。 C语言并不能直接调用ecall, 需要通过内联汇编来实现。 // libs/sbi.c #include #include //SBI编号和函数的对应 uint64_t SBI_SET_TIMER = 0; uint64_t SBI_CONSOLE_PUTCHAR = 1; uint64_t SBI_CONSOLE_GETCHAR = 2; uint64_t SBI_CLEAR_IPI = 3; uint64_t SBI_SEND_IPI = 4; uint64_t SBI_REMOTE_FENCE_I = 5; uint64_t SBI_REMOTE_SFENCE_VMA = 6; uint64_t SBI_REMOTE_SFENCE_VMA_ASID = 7; uint64_t SBI_SHUTDOWN = 8; //sbi_call函数是我们关注的核心 uint64_t sbi_call(uint64_t sbi_type, uint64_t arg0, uint64_t arg1, uint64_t arg2) { uint64_t ret_val; __asm__ volatile ( \"mv x17, %[sbi_type]\\n\" \"mv x10, %[arg0]\\n\" \"mv x11, %[arg1]\\n\" \"mv x12, %[arg2]\\n\" //mv操作把参数的数值放到寄存器里 \"ecall\\n\" //参数放好之后，通过ecall, 交给OpenSBI来执行 \"mv %[ret_val], x10\" //OpenSBI按照riscv的calling convention,把返回值放到x10寄存器里 //我们还需要自己通过内联汇编把返回值拿到我们的变量里 : [ret_val] \"=r\" (ret_val) : [sbi_type] \"r\" (sbi_type), [arg0] \"r\" (arg0), [arg1] \"r\" (arg1), [arg2] \"r\" (arg2) : \"memory\" ); return ret_val; } void sbi_console_putchar(unsigned char ch) { sbi_call(SBI_CONSOLE_PUTCHAR, ch, 0, 0); //注意这里ch隐式类型转换为int64_t } void sbi_set_timer(unsigned long long stime_value) { sbi_call(SBI_SET_TIMER, stime_value, 0, 0); } [!TIP|style:flat|label:知识点] 函数调用与calling convention 我们知道，编译器将高级语言源代码翻译成汇编代码。对于汇编语言而言，在最简单的编程模型中，所能够利用的只有指令集中提供的指令、各通用寄存器、 CPU 的状态、内存资源。那么，在高级语言中，我们进行一次函数调用，编译器要做哪些工作利用汇编语言来实现这一功能呢？ 显然并不是仅用一条指令跳转到被调用函数开头地址就行了。我们还需要考虑： 如何传递参数？ 如何传递返回值？ 如何保证函数返回后能从我们期望的位置继续执行？ 等更多事项。通常编译器按照某种规范去翻译所有的函数调用，这种规范被称为 calling convention 。值得一提的是，为了实现函数调用，我们需要预先分配一块内存作为 调用栈 ，后面会看到调用栈在函数调用过程中极其重要。你也可以理解为什么第一章刚开始我们就要分配栈了。 可以参考riscv calling convention 现在可以输出一个字符了，有了第一个，就会有第二个第三个……第无数个。 这样我们就可以通过sbi_console_putchar()来输出一个字符。接下来我们要做的事情就像月饼包装，把它封了一层又一层。 console.c只是简单地封装一下 // kern/driver/console.c#include #include void cons_putc(int c) { sbi_console_putchar((unsigned char)c); } stdio.c里面实现了一些函数，注意我们已经实现了ucore版本的puts函数: cputs() // kern/libs/stdio.c #include #include #include /* HIGH level console I/O */ /* * * cputch - writes a single character @c to stdout, and it will * increace the value of counter pointed by @cnt. * */ static void cputch(int c, int *cnt) { cons_putc(c); (*cnt)++; } /* cputchar - writes a single character to stdout */ void cputchar(int c) { cons_putc(c); } int cputs(const char *str) { int cnt = 0; char c; while ((c = *str++) != '\\0') { cputch(c, &cnt); } cputch('\\n', &cnt); return cnt; } 我们还在libs/printfmt.c实现了一些复杂的格式化输入输出函数。最后得到的cprintf()函数仍在kern/libs/stdio.c定义，功能和C标准库的printf()基本相同。 可能你注意到我们用到一个头文件defs.h, 我们在里面定义了一些有用的宏和类型 // libs/defs.h #ifndef __LIBS_DEFS_H__ #define __LIBS_DEFS_H__ ... /* Represents true-or-false values */ typedef int bool; /* Explicitly-sized versions of integer types */ typedef char int8_t; typedef unsigned char uint8_t; typedef short int16_t; typedef unsigned short uint16_t; typedef int int32_t; typedef unsigned int uint32_t; typedef long long int64_t; typedef unsigned long long uint64_t; ... /* * * Rounding operations (efficient when n is a power of 2) * Round down to the nearest multiple of n * */ #define ROUNDDOWN(a, n) ({ \\ size_t __a = (size_t)(a); \\ (typeof(a))(__a - __a % (n)); \\ }) ... #endif printfmt.c还依赖一个头文件riscv.h,这个头文件主要定义了若干和riscv架构相关的宏，尤其是将一些内联汇编的代码封装成宏，使得我们更方便地使用内联汇编来读写寄存器。当然这里我们还没有用到它的强大功能。 // libs/riscv.h ... #define read_csr(reg) ({ unsigned long __tmp; \\ asm volatile (\"csrr %0, \" #reg : \"=r\"(__tmp)); \\ __tmp; }) //通过内联汇编包装了 csrr 指令为 read_csr() 宏 #define write_csr(reg, val) ({ \\ if (__builtin_constant_p(val) && (unsigned long)(val) 到现在，我们已经看过了一个最小化的内核的各个部分，虽然一些部分没有逐行细读，但我们也知道它在做什么。 是不是感觉好麻烦啊！输出一个字符都那么麻烦。那是肯定的噢，可以稍微喘下气，脑子里回忆一下，我们是怎么一层一层剥开，又是如何一层一层包装的。好玩吧！ 但一直到现在我们还没进行过编译。下面就把它编译一下跑起来。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-11 16:58:58 "},"Lab0.5/编译运行.html":{"url":"Lab0.5/编译运行.html","title":"编译运行","keywords":"","body":"编译运行 我们需要：编译所有的源代码，把目标文件链接起来，生成elf文件，生成bin硬盘镜像，用qemu跑起来 这一系列复杂的命令，我们不想每次用到的时候都敲一遍，所以我们使用魔改的祖传Makefile。 我们的Makefile还依赖tools/function.mk 在源代码的根目录下make qemu, 我们就把ucore跑起来了。 它输出一行(NKU.CC) os is loading, 然后进入死循环。 关于Makefile的语法, 如果不熟悉, 可以回看LAB0的前导知识。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-11 15:53:37 "},"Lab0.5/项目组成与执行流.html":{"url":"Lab0.5/项目组成与执行流.html","title":"项目组成与执行流","keywords":"","body":"项目组成与执行流 lab0的项目组成: ── Makefile ├── kern │ ├── debug │ │ ├── assert.h │ │ ├── kdebug.c │ │ ├── kdebug.h │ │ ├── kmonitor.c │ │ ├── kmonitor.h │ │ ├── panic.c │ │ └── stab.h │ ├── driver │ │ ├── clock.c │ │ ├── clock.h │ │ ├── console.c │ │ ├── console.h │ │ ├── intr.c │ │ ├── intr.h │ │ ├── kbdreg.h │ │ ├── picirq.c │ │ └── picirq.h │ ├── init │ │ ├── entry.S │ │ └── init.c │ ├── libs │ │ ├── readline.c │ │ └── stdio.c │ ├── mm │ │ ├── memlayout.h │ │ ├── mmu.h │ │ ├── pmm.c │ │ └── pmm.h │ └── trap │ ├── trap.c │ ├── trap.h │ └── trapentry.S ├── libs │ ├── defs.h │ ├── elf.h │ ├── error.h │ ├── printfmt.c │ ├── riscv.h │ ├── sbi.c │ ├── sbi.h │ ├── stdarg.h │ ├── stdio.h │ ├── string.c │ └── string.h └── tools ├── function.mk ├── kernel.ld 内核启动 kern/init/entry.S: OpenSBI启动之后将要跳转到的一段汇编代码。在这里进行内核栈的分配，然后转入C语言编写的内核初始化函数。 kern/init/init.c： C语言编写的内核入口点。主要包含kern_init()函数，从kern/entry.S跳转过来完成其他初始化工作。 设备驱动 kern/driver/console.c(h): 在QEMU上模拟的时候，唯一的“设备”是虚拟的控制台，通过OpenSBI接口使用。简单封装了OpenSBI的字符读写接口，向上提供给输入输出库。 库文件 libs/riscv.h: 以宏的方式，定义了riscv指令集的寄存器和指令。如果在C语言里使用riscv指令，需要通过内联汇编和寄存器的编号。这个头文件把寄存器编号和内联汇编都封装成宏，使得我们可以用类似函数的方式在C语言里执行一句riscv指令。 libs/sbi.c(h): 封装OpenSBI接口为函数。如果想在C语言里使用OpenSBI提供的接口，需要使用内联汇编。这个头文件把OpenSBI的内联汇编调用封装为函数。 libs/defs.h: 定义了一些常用的类型和宏。 例如bool 类型（C语言不自带，这里typedef int bool)。 libs/string.c(h): 一些对字符数组进行操作的函数，如memset(),memcpy()等，类似C语言的string.h。 kern/libs/stdio.c, libs/readline.c, libs/printfmt.c: 实现了一套标准输入输出，功能类似于C语言的printf() 和getchar()。需要内核为输入输出函数提供两个桩函数（stub): 输出一个字符的函数，输入一个字符的函数。在这里，是cons_getc()和cons_putc()。 kern/errors.h: 定义了一些内核错误类型的宏。 编译、链接脚本 tools/kernel.ld: ucore的链接脚本(link script), 告诉链接器如何将目标文件的section组合为可执行文件。 tools/function.mk: 定义Makefile中使用的一些函数 Makefile: GNU make编译脚本 执行流 最小可执行内核的执行流为: 加电 -> OpenSBI启动 -> 跳转到 0x80200000 (kern/init/entry.S）->进入kern_init()函数（kern/init/init.c) ->调用cprintf()输出一行信息->结束 cprintf()函数的执行流为: 接受一个格式化字符串和若干个需要输出的变量作为参数 -> 解析格式化的字符串，把需要输出的各种变量转化为一串字符 -> 调用console.c提供的字符输出接口依次输出所有字符（实际上console.c又封装了sbi.c向上提供的OpenSBI接口) Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-11 17:05:03 "},"Lab1/":{"url":"Lab1/","title":"LAB1：中断机制","keywords":"","body":"Lab1：中断机制 中断（interrupt）机制，就是不管CPU现在手里在干啥活，收到“中断”的时候，都先放下来去处理其他事情，处理完其他事情可能再回来干手头的活。 例如，CPU要向磁盘发一个读取数据的请求，由于磁盘速度相对CPU较慢，在“发出请求”到“收到磁盘数据\"之间会经过很多时间周期，如果CPU干等着磁盘干活就相当于CPU在磨洋工。因此我们可以让CPU发出读数据的请求后立刻开始干另一件事情。但是，等一段时间之后，磁盘的数据取到了，而CPU在干其他的事情，我们怎么办才能让CPU知道之前发出的磁盘请求已经完成了呢？我们可以让磁盘给CPU一个“中断”，让CPU放下手里的事情来接受磁盘的数据。 再比如，为了保证CPU正在执行的程序不会永远运行下去，我们需要定时检查一下它是否已经运行“超时”。想象有一个程序由于bug进入了死循环，如果CPU一直运行这个程序，那么其他的所有程序都会因为等待CPU资源而无法运行，造成严重的资源浪费。但是检查是否超时，需要CPU执行一段代码，也就是让CPU暂停当前执行的程序。我们不能假设当前执行的程序会主动地定时让出CPU，那么就需要CPU定时“打断”当前程序的执行，去进行一些处理，这通过时钟中断来实现。 从这些描述我们可以看出，中断机制需要软件硬件一起来支持。硬件进行中断和异常的发现，然后交给软件来进行处理。回忆一下组成原理课程中学到的各个控制寄存器以及他们的用途（下一小节会进行简单回顾），这些寄存器构成了重要的硬件/软件接口。由此，我们也可以得到在一般OS中进行中断处理支持的方法： 编写相应的中断处理代码 在启动中正确设置控制寄存器 CPU捕获异常 控制转交给相应中断处理代码进行处理 返回正在运行的程序 由于中断处理需要进行较高权限的操作，中断处理程序一般处于内核态，或者说，处于“比被打断的程序更高的特权级”。注意，在RISCV里，中断(interrupt)和异常(exception)统称为\"trap\"。 这次实验就一起来看一下ucore是如何支持中断处理的。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-12 23:39:03 "},"Lab1/实验目的.html":{"url":"Lab1/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 了解CPU的中断机制 了解RISC-v架构是如何支持CPU中断的 掌握与软件相关的中断处理 掌握时钟中断管理 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-12 21:35:47 "},"Lab1/实验内容.html":{"url":"Lab1/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 跟着实验指导书理解lab1框架代码。 阅读RISC-V手册有关中断部分。 完成练习。 撰写并提交实验报告。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-12 21:39:00 "},"Lab1/练习.html":{"url":"Lab1/练习.html","title":"练习","keywords":"","body":"练习 练习1：描述处理中断异常的流程 像LAB0.5里的执行流一样描述ucore是如何处理中断异常的。从异常的产生开始。 练习2：对于任何中断，都需要保存所有寄存器吗？为什么？ 练习3：触发、捕获、处理异常 编程：在任意位置触发一条非法指令异常（如：mret），在 kern/trap/trap.c的异常处理函数中捕获，并对其进行处理，简单输出异常类型和指令即可。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-12 21:44:25 "},"Lab1/RISC-V中断相关.html":{"url":"Lab1/RISC-V中断相关.html","title":"RISC-V中断相关","keywords":"","body":"RISC-V中断相关 中断机制 中断（interrupt）机制，就是不管CPU现在手里在干啥活，收到“中断”的时候，都先放下来去处理其他事情，处理完其他事情可能再回来干手头的活。 例如，CPU要向磁盘发一个读取数据的请求，由于磁盘速度相对CPU较慢，在“发出请求”到“收到磁盘数据\"之间会经过很多时间周期，如果CPU干等着磁盘干活就相当于CPU在磨洋工。因此我们可以让CPU发出读数据的请求后立刻开始干另一件事情。但是，等一段时间之后，磁盘的数据取到了，而CPU在干其他的事情，我们怎么办才能让CPU知道之前发出的磁盘请求已经完成了呢？我们可以让磁盘给CPU一个“中断”，让CPU放下手里的事情来接受磁盘的数据。 再比如，为了保证CPU正在执行的程序不会永远运行下去，我们需要定时检查一下它是否已经运行“超时”。想象有一个程序由于bug进入了死循环，如果CPU一直运行这个程序，那么其他的所有程序都会因为等待CPU资源而无法运行，造成严重的资源浪费。但是检查是否超时，需要CPU执行一段代码，也就是让CPU暂停当前执行的程序。我们不能假设当前执行的程序会主动地定时让出CPU，那么就需要CPU定时“打断”当前程序的执行，去进行一些处理，这通过时钟中断来实现。 从这些描述我们可以看出，中断机制需要软件硬件一起来支持。硬件进行中断和异常的发现，然后交给软件来进行处理。回忆一下组成原理课程中学到的各个控制寄存器以及他们的用途（下一小节会进行简单回顾），这些寄存器构成了重要的硬件/软件接口。由此，我们也可以得到在一般OS中进行中断处理支持的方法： 编写相应的中断处理代码 在启动中正确设置控制寄存器 CPU捕获异常 控制转交给相应中断处理代码进行处理 返回正在运行的程序 由于中断处理需要进行较高权限的操作，中断处理程序一般处于内核态，或者说，处于“比被打断的程序更高的特权级”。注意，在RISCV里，中断(interrupt)和异常(exception)统称为\"trap\"。 寄存器 除了32个通用寄存器之外，RISCV架构还有大量的 控制状态寄存器 Control and Status Registers(CSRs)。其中有几个重要的寄存器和中断机制有关。 有些时候，禁止CPU产生中断很有用。（就像你在做重要的事情，如操作系统lab的时候，并不想被打断）。所以，sstatus寄存器(Supervisor Status Register)里面有一个二进制位SIE(supervisor interrupt enable，在RISCV标准里是2^1 对应的二进制位)，数值为0的时候，如果当程序在S态运行，将禁用全部中断。（对于在U态运行的程序，SIE这个二进制位的数值没有任何意义），sstatus还有一个二进制位UIE(user interrupt enable)可以在置零的时候禁止用户态程序产生中断。 在中断产生后，应该有个中断处理程序来处理中断。CPU怎么知道中断处理程序在哪？实际上，RISCV架构有个CSR叫做stvec(Supervisor Trap Vector Base Address Register)，即所谓的”中断向量表基址”。中断向量表的作用就是把不同种类的中断映射到对应的中断处理程序。如果只有一个中断处理程序，那么可以让stvec直接指向那个中断处理程序的地址。 对于RISCV架构，stvec会把最低位的两个二进制位用来编码一个“模式”，如果是“00”就说明更高的SXLEN-2个二进制位存储的是唯一的中断处理程序的地址(SXLEN是stval寄存器的位数)，如果是“01”说明更高的SXLEN-2个二进制位存储的是中断向量表基址，通过不同的异常原因来索引中断向量表。但是怎样用62个二进制位编码一个64位的地址？RISCV架构要求这个地址是四字节对齐的，总是在较高的62位后补两个0。 [!NOTE|style:flat] 手册P110 机器和监管者自陷向量（trap-vector）基地址寄存器（ mtvec和 stvec) CSR。他们是位宽为 XLEN的读 /写寄存器，用于保存自陷向量的配置，包括向量基址（ BASE）和向量模式 （MODE）。 BASE域中的值必须按 4字节对齐。 MODE = 0表示所有异常都把 PC设置为 BASE。 MODE = 1会在一部中断时将 PC设置为 (𝑩𝑨𝑺𝑬+(𝟒×𝒄𝒂𝒖𝒔𝒆))。 当我们触发中断进入 S 态进行处理时，以下寄存器会被硬件自动设置，将一些信息提供给中断处理程序： sepc(supervisor exception program counter)，它会记录触发中断的那条指令的地址； scause，它会记录中断发生的原因，还会记录该中断是不是一个外部中断； stval，它会记录一些中断处理所需要的辅助信息，比如指令获取(instruction fetch)、访存、缺页异常，它会把发生问题的目标地址或者出错的指令记录下来，这样我们在中断处理程序中就知道处理目标了。 特权指令 RISCV支持以下和中断相关的特权指令： ecall(environment call)，当我们在 S 态执行这条指令时，会触发一个 ecall-from-s-mode-exception，从而进入 M 模式中的中断处理流程（如设置定时器等）；当我们在 U 态执行这条指令时，会触发一个 ecall-from-u-mode-exception，从而进入 S 模式中的中断处理流程（常用来进行系统调用）。 sret，用于 S 态中断返回到 U 态，实际作用为pc←sepc，回顾sepc定义，返回到通过中断进入 S 态之前的地址。 ebreak(environment break)，执行这条指令会触发一个断点中断从而进入中断处理流程。 mret，用于 M 态中断返回到 S 态或 U 态，实际作用为pc←mepc，回顾sepc定义，返回到通过中断进入 M 态之前的地址。（一般不用涉及） [!TIP|style:flat] 关于上面提及的内容，要去手册里找相关内容，然后看明白！ Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-12 22:20:56 "},"Lab1/上下文处理.html":{"url":"Lab1/上下文处理.html","title":"上下文处理","keywords":"","body":"上下文处理 我们已经知道,在发生中断的时候, CPU会跳到stvec.我们准备采用Direct模式,也就是只有一个中断处理程序, stvec直接跳到中断处理程序的入口点,那么需要我们对stvec寄存器做初始化. 上下文 中断的处理需要“放下当前的事情但之后还能回来接着之前往下做”，对于CPU来说，实际上只需要把原先的寄存器保存下来，做完其他事情把寄存器恢复回来就可以了。这些寄存器也被叫做CPU的context(上下文，情境)。 我们要用汇编实现上下文切换(context switch)机制，这包含两步： 保存CPU的寄存器（上下文）到内存中（栈上） 从内存中（栈上）恢复CPU的寄存器 [!NOTE|style:flat] 通用寄存器的介绍见中文手册42页。 为了方便我们组织上下文的数据（几十个寄存器），我们定义一个结构体。 // kern/trap/trap.h #ifndef __KERN_TRAP_TRAP_H__ #define __KERN_TRAP_TRAP_H__ #include struct pushregs { uintptr_t zero; // Hard-wired zero uintptr_t ra; // Return address uintptr_t sp; // Stack pointer uintptr_t gp; // Global pointer uintptr_t tp; // Thread pointer uintptr_t t0; // Temporary uintptr_t t1; // Temporary uintptr_t t2; // Temporary uintptr_t s0; // Saved register/frame pointer uintptr_t s1; // Saved register uintptr_t a0; // Function argument/return value uintptr_t a1; // Function argument/return value uintptr_t a2; // Function argument uintptr_t a3; // Function argument uintptr_t a4; // Function argument uintptr_t a5; // Function argument uintptr_t a6; // Function argument uintptr_t a7; // Function argument uintptr_t s2; // Saved register uintptr_t s3; // Saved register uintptr_t s4; // Saved register uintptr_t s5; // Saved register uintptr_t s6; // Saved register uintptr_t s7; // Saved register uintptr_t s8; // Saved register uintptr_t s9; // Saved register uintptr_t s10; // Saved register uintptr_t s11; // Saved register uintptr_t t3; // Temporary uintptr_t t4; // Temporary uintptr_t t5; // Temporary uintptr_t t6; // Temporary }; struct trapframe { struct pushregs gpr; uintptr_t status; //sstatus uintptr_t epc; //sepc uintptr_t badvaddr; //sbadvaddr uintptr_t cause; //scause }; void trap(struct trapframe *tf); C语言里面的结构体，是若干个变量在内存里直线排列。也就是说，一个trapFrame结构体占据36个uintptr_t的空间（在64位RISCV架构里我们定义uintptr_t为64位无符号整数），里面依次排列通用寄存器x0到x31,然后依次排列4个和中断相关的CSR, 我们希望中断处理程序能够利用这几个CSR的数值。 保存上下文 我们在理论课上也学到了保存上下文是用汇编语言实现的。首先我们定义一个汇编宏 SAVE_ALL, 用来保存所有寄存器到栈顶（实际上把一个trapFrame结构体放到了栈顶）。 # kern/trap/trapentry.S #include .macro SAVE_ALL #定义汇编宏 csrw sscratch, sp #保存原先的栈顶指针到sscratch addi sp, sp, -36 * REGBYTES #REGBYTES是riscv.h定义的常量，表示一个寄存器占据几个字节 #让栈顶指针向低地址空间延伸 36个寄存器的空间，可以放下一个trapFrame结构体。 #除了32个通用寄存器，我们还要保存4个和中断有关的CSR #依次保存32个通用寄存器。但栈顶指针需要特殊处理。 #因为我们想在trapFrame里保存分配36个REGBYTES之前的sp #也就是保存之前写到sscratch里的sp的值 STORE x0, 0*REGBYTES(sp) STORE x1, 1*REGBYTES(sp) STORE x3, 3*REGBYTES(sp) STORE x4, 4*REGBYTES(sp) STORE x5, 5*REGBYTES(sp) STORE x6, 6*REGBYTES(sp) STORE x7, 7*REGBYTES(sp) STORE x8, 8*REGBYTES(sp) STORE x9, 9*REGBYTES(sp) STORE x10, 10*REGBYTES(sp) STORE x11, 11*REGBYTES(sp) STORE x12, 12*REGBYTES(sp) STORE x13, 13*REGBYTES(sp) STORE x14, 14*REGBYTES(sp) STORE x15, 15*REGBYTES(sp) STORE x16, 16*REGBYTES(sp) STORE x17, 17*REGBYTES(sp) STORE x18, 18*REGBYTES(sp) STORE x19, 19*REGBYTES(sp) STORE x20, 20*REGBYTES(sp) STORE x21, 21*REGBYTES(sp) STORE x22, 22*REGBYTES(sp) STORE x23, 23*REGBYTES(sp) STORE x24, 24*REGBYTES(sp) STORE x25, 25*REGBYTES(sp) STORE x26, 26*REGBYTES(sp) STORE x27, 27*REGBYTES(sp) STORE x28, 28*REGBYTES(sp) STORE x29, 29*REGBYTES(sp) STORE x30, 30*REGBYTES(sp) STORE x31, 31*REGBYTES(sp) # RISCV不能直接从CSR写到内存, 需要csrr把CSR读取到通用寄存器，再从通用寄存器STORE到内存 csrrw s0, sscratch, x0 csrr s1, sstatus csrr s2, sepc csrr s3, sbadaddr csrr s4, scause STORE s0, 2*REGBYTES(sp) STORE s1, 32*REGBYTES(sp) STORE s2, 33*REGBYTES(sp) STORE s3, 34*REGBYTES(sp) STORE s4, 35*REGBYTES(sp) .endm #汇编宏定义结束 恢复上下文 然后是恢复上下文的汇编宏，恢复的顺序和当时保存的顺序反过来，先加载两个CSR, 再加载通用寄存器。 # kern/trap/trapentry.S .macro RESTORE_ALL LOAD s1, 32*REGBYTES(sp) LOAD s2, 33*REGBYTES(sp) # 注意之前保存的几个CSR并不都需要恢复 csrw sstatus, s1 csrw sepc, s2 # 恢复sp之外的通用寄存器，这时候还需要根据sp来确定其他寄存器数值保存的位置 LOAD x1, 1*REGBYTES(sp) LOAD x3, 3*REGBYTES(sp) LOAD x4, 4*REGBYTES(sp) LOAD x5, 5*REGBYTES(sp) LOAD x6, 6*REGBYTES(sp) LOAD x7, 7*REGBYTES(sp) LOAD x8, 8*REGBYTES(sp) LOAD x9, 9*REGBYTES(sp) LOAD x10, 10*REGBYTES(sp) LOAD x11, 11*REGBYTES(sp) LOAD x12, 12*REGBYTES(sp) LOAD x13, 13*REGBYTES(sp) LOAD x14, 14*REGBYTES(sp) LOAD x15, 15*REGBYTES(sp) LOAD x16, 16*REGBYTES(sp) LOAD x17, 17*REGBYTES(sp) LOAD x18, 18*REGBYTES(sp) LOAD x19, 19*REGBYTES(sp) LOAD x20, 20*REGBYTES(sp) LOAD x21, 21*REGBYTES(sp) LOAD x22, 22*REGBYTES(sp) LOAD x23, 23*REGBYTES(sp) LOAD x24, 24*REGBYTES(sp) LOAD x25, 25*REGBYTES(sp) LOAD x26, 26*REGBYTES(sp) LOAD x27, 27*REGBYTES(sp) LOAD x28, 28*REGBYTES(sp) LOAD x29, 29*REGBYTES(sp) LOAD x30, 30*REGBYTES(sp) LOAD x31, 31*REGBYTES(sp) # 最后恢复sp LOAD x2, 2*REGBYTES(sp) .endm 中断入口 真正的入口点就是去调用这两个宏定义 .globl __alltraps .align(2) #中断入口点 __alltraps必须四字节对齐 __alltraps: SAVE_ALL #保存上下文 move a0, sp #传递参数。 #按照RISCV calling convention, a0寄存器传递参数给接下来调用的函数trap。 #trap是trap.c里面的一个C语言函数，也就是我们的中断处理程序 jal trap #trap函数指向完之后，会回到这里向下继续执行__trapret里面的内容，RESTORE_ALL,sret .globl __trapret __trapret: RESTORE_ALL # return from supervisor call sret 我们可以看到，trapentry.S这个中断入口点的作用是保存和恢复上下文，并把上下文包装成结构体送到trap函数那里去。下面我们就去看看trap函数里面做些什么。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-12 23:16:04 "},"Lab1/中断处理程序.html":{"url":"Lab1/中断处理程序.html","title":"中断处理程序","keywords":"","body":"中断处理程序 scause 当处理自陷时， cause CSR中被写入一个指示导致 自陷的事件的代码。如果自陷由中断引起，则置上中断位。“异常代码”字段包含指示最后一个异常的代 码。具体的中断/异常映射关系，见中文手册100页。 初始化 中断处理需要初始化，所以我们在init.c里调用一些初始化的函数 // kern/init/init.c #include int kern_init(void) { extern char edata[], end[]; memset(edata, 0, end - edata); cons_init(); // init the console const char *message = \"(THU.CST) os is loading ...\\n\"; cprintf(\"%s\\n\\n\", message); print_kerninfo(); // grade_backtrace(); //trap.h的函数，初始化中断 idt_init(); // init interrupt descriptor table //clock.h的函数，初始化时钟中断 clock_init(); //intr.h的函数，使能中断 intr_enable(); // LAB1: CAHLLENGE 1 If you try to do it, uncomment lab1_switch_test() // user/kernel mode switch test // lab1_switch_test(); /* do nothing */ while (1) ; } // kern/trap/trap.c void idt_init(void) { extern void __alltraps(void); //约定：若中断前处于S态，sscratch为0 //若中断前处于U态，sscratch存储内核栈地址 //那么之后就可以通过sscratch的数值判断是内核态产生的中断还是用户态产生的中断 //我们现在是内核态所以给sscratch置零 write_csr(sscratch, 0); //我们保证__alltraps的地址是四字节对齐的，将__alltraps这个符号的地址直接写到stvec寄存器 write_csr(stvec, &__alltraps); } //kern/driver/intr.c #include #include /* intr_enable - enable irq interrupt, 设置sstatus的Supervisor中断使能位 */ void intr_enable(void) { set_csr(sstatus, SSTATUS_SIE); } /* intr_disable - disable irq interrupt */ void intr_disable(void) { clear_csr(sstatus, SSTATUS_SIE); } 处理 trap.c的中断处理函数trap, 实际上把中断处理,异常处理的工作分发给了interrupt_handler()，exception_handler(), 这些函数再根据中断或异常的不同类型来处理。 // kern/trap/trap.c /* trap_dispatch - dispatch based on what type of trap occurred */ static inline void trap_dispatch(struct trapframe *tf) { //scause的最高位是1，说明trap是由中断引起的 if ((intptr_t)tf->cause interrupt_handler()和exception_handler()的实现还比较简单，只是简单地根据scause的数值更仔细地分了下类，做了一些输出就直接返回了。switch里的各种case, 如IRQ_U_SOFT,CAUSE_USER_ECALL,是riscv ISA 标准里规定的。我们在riscv.h里定义了这些常量。我们接下来主要关注时钟中断的处理。 在这里我们对时钟中断进行了一个简单的处理，即每次触发时钟中断的时候，我们会给一个计数器加一，并且设定好下一次时钟中断。当计数器加到100的时候，我们会输出一个100ticks表示我们触发了100次时钟中断。通过在模拟器中观察输出我们即刻看到是否正确触发了时钟中断，从而验证我们实现的异常处理机制。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-12 23:22:03 "},"Lab1/时钟中断.html":{"url":"Lab1/时钟中断.html","title":"时钟中断","keywords":"","body":"时钟中断 时钟中断需要CPU硬件的支持。CPU以\"时钟周期\"为工作的基本时间单位，对逻辑门的时序电路进行同步。 我们的“时钟中断”实际上就是”每隔若干个时钟周期执行一次的程序“。 ”若干个时钟周期“是多少个？太短了肯定不行。如果时钟中断处理程序需要100个时钟周期执行，而你每50个时钟周期就触发一个时钟中断，那么间隔时间连一个完整的时钟中断程序都跑不完。如果你200个时钟周期就触发一个时钟中断，那么CPU的时间将有一半消耗在时钟中断，开销太大。一般而言，可以设置时钟中断间隔设置为CPU频率的1%，也就是每秒钟触发100次时钟中断，避免开销过大。 我们用到的RISCV对时钟中断的硬件支持包括： OpenSBI提供的sbi_set_timer()接口，可以传入一个时刻，让它在那个时刻触发一次时钟中断 rdtime伪指令，读取一个叫做time的CSR的数值，表示CPU启动之后经过的真实时间。在不同硬件平台，时钟频率可能不同。在QEMU上，这个时钟的频率是10MHz, 每过1s, rdtime返回的结果增大10000000 [!NOTE|style:flat] 在RISCV32和RISCV64架构中，time寄存器都是64位的。 rdcycle伪指令可以读取经过的时钟周期数目，对应一个寄存器cycle 注意，我们需要“每隔若干时间就发生一次时钟中断”，但是OpenSBI提供的接口一次只能设置一个时钟中断事件。我们采用的方式是：一开始只设置一个时钟中断，之后每次发生时钟中断的时候，设置下一次的时钟中断。 在clock.c里面初始化时钟并封装一些接口 //libs/sbi.c //当time寄存器(rdtime的返回值)为stime_value的时候触发一个时钟中断 void sbi_set_timer(unsigned long long stime_value) { sbi_call(SBI_SET_TIMER, stime_value, 0, 0); } // kern/driver/clock.c #include #include #include #include #include //volatile告诉编译器这个变量可能在其他地方被瞎改一通，所以编译器不要对这个变量瞎优化 volatile size_t ticks; //对64位和32位架构，读取time的方法是不同的 //32位架构下，需要把64位的time寄存器读到两个32位整数里，然后拼起来形成一个64位整数 //64位架构简单的一句rdtime就可以了 //__riscv_xlen是gcc定义的一个宏，可以用来区分是32位还是64位。 static inline uint64_t get_time(void) {//返回当前时间 #if __riscv_xlen == 64 uint64_t n; __asm__ __volatile__(\"rdtime %0\" : \"=r\"(n)); return n; #else uint32_t lo, hi, tmp; __asm__ __volatile__( \"1:\\n\" \"rdtimeh %0\\n\" \"rdtime %1\\n\" \"rdtimeh %2\\n\" \"bne %0, %2, 1b\" : \"=&r\"(hi), \"=&r\"(lo), \"=&r\"(tmp)); return ((uint64_t)hi 回来看trap.c里面时钟中断处理的代码, 还是很简单的：每秒100次时钟中断，触发每次时钟中断后设置10ms后触发下一次时钟中断，每触发100次时钟中断（1秒钟）输出一行信息到控制台。 // kern/trap/trap.c #include #define TICK_NUM 100 static void print_ticks() { cprintf(\"%d ticks\\n\", TICK_NUM); #ifdef DEBUG_GRADE cprintf(\"End of Test.\\n\"); panic(\"EOT: kernel seems ok.\"); #endif } void interrupt_handler(struct trapframe *tf) { intptr_t cause = (tf->cause > 1; switch (cause) { /* blabla 其他case*/ case IRQ_S_TIMER: clock_set_next_event();//发生这次时钟中断的时候，我们要设置下一次时钟中断 if (++ticks % TICK_NUM == 0) { print_ticks(); } break; /* blabla 其他case*/ } 现在执行make qemu, 应该能看到打印一行行的100 ticks。 [!TIP|style:flat] 时钟是属于外部设备了。之所以给大家呈现着一块，是为了能够更好的理解，操作系统与外设如何进行交互。中断来临如何处理。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-12 23:33:53 "},"Lab1/项目组成与执行流.html":{"url":"Lab1/项目组成与执行流.html","title":"项目组成与执行流","keywords":"","body":"项目组成与执行流 项目组成 lab1 ├── Makefile ├── kern │ ├── debug │ │ ├── assert.h │ │ ├── kdebug.c │ │ ├── kdebug.h │ │ ├── kmonitor.c │ │ ├── kmonitor.h │ │ ├── panic.c │ │ └── stab.h │ ├── driver │ │ ├── clock.c │ │ ├── clock.h │ │ ├── console.c │ │ ├── console.h │ │ ├── intr.c │ │ └── intr.h │ ├── init │ │ ├── entry.S │ │ └── init.c │ ├── libs │ │ └── stdio.c │ ├── mm │ │ ├── memlayout.h │ │ ├── mmu.h │ │ ├── pmm.c │ │ └── pmm.h │ └── trap │ ├── trap.c │ ├── trap.h │ └── trapentry.S ├── lab1.md ├── libs │ ├── defs.h │ ├── error.h │ ├── printfmt.c │ ├── readline.c │ ├── riscv.h │ ├── sbi.c │ ├── sbi.h │ ├── stdarg.h │ ├── stdio.h │ ├── string.c │ └── string.h ├── readme.md └── tools ├── function.mk ├── gdbinit ├── grade.sh ├── kernel.ld ├── sign.c └── vector.c 9 directories, 43 files 硬件驱动层 kern/driver/clock.c(h): 通过OpenSBI的接口, 可以读取当前时间(rdtime), 设置时钟事件(sbi_set_timer)，是时钟中断必需的硬件支持。 kern/driver/intr.c(h): 中断也需要CPU的硬件支持，这里提供了设置中断使能位的接口（其实只封装了一句riscv指令）。 初始化 kern/init/init.c: 需要调用中断机制的初始化函数。 中断处理 kern/trap/trapentry.S: 我们把中断入口点设置为这段汇编代码。这段汇编代码把寄存器的数据挪来挪去，进行上下文切换。 kern/trap/trap.c(h): 分发不同类型的中断给不同的handler, 完成上下文切换之后对中断的具体处理，例如外设中断要处理外设发来的信息，时钟中断要触发特定的事件。中断处理初始化的函数也在这里，主要是把中断向量表(stvec)设置成所有中断都要跳到trapentry.S进行处理。 执行流 没有啦！需要自己总结，撰写实验报告噢！ Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-08-12 23:36:36 "},"Lab2/":{"url":"Lab2/","title":"LAB2","keywords":"","body":"Lab2 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab2/实验目的.html":{"url":"Lab2/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab2/实验内容.html":{"url":"Lab2/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab3/":{"url":"Lab3/","title":"LAB3","keywords":"","body":"Lab3 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab3/实验目的.html":{"url":"Lab3/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab3/实验内容.html":{"url":"Lab3/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab4/":{"url":"Lab4/","title":"LAB4","keywords":"","body":"Lab4 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab4/实验目的.html":{"url":"Lab4/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab4/实验内容.html":{"url":"Lab4/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab5/":{"url":"Lab5/","title":"LAB5","keywords":"","body":"Lab5 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab5/实验目的.html":{"url":"Lab5/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab5/实验内容.html":{"url":"Lab5/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab6/":{"url":"Lab6/","title":"LAB6","keywords":"","body":"Lab6 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab6/实验目的.html":{"url":"Lab6/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab6/实验内容.html":{"url":"Lab6/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab7/":{"url":"Lab7/","title":"LAB7","keywords":"","body":"Lab7 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab7/实验目的.html":{"url":"Lab7/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab7/实验内容.html":{"url":"Lab7/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab8/":{"url":"Lab8/","title":"LAB8","keywords":"","body":"Lab8 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab8/实验目的.html":{"url":"Lab8/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab8/实验内容.html":{"url":"Lab8/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "}}