{"./":{"url":"./","title":"Introduction","keywords":"","body":"uCore OS(on RISC-V32)实验指导书和源码网址 ucore实验指导书 ucore labs 1-8 源码和参考答案 实验总体流程 认真上操作系统的理论课程； 阅读ucore实验指导书，并参考其内容完成联系和实验报告; 在实验环境中完成实验并提交到自己的github上； 遇到问题，首先查询手册等其他资料，先自行解决； 如若不能解决，可在飞书群里提问，可以互相讨论，有助教老师答疑。 学习目标与对应手段 掌握OS基本概念：通过上课与学习教材，能理解OS原理与概念；阅读指导书并分析源码，能理解lab_codes_answer的labs运行结果。 掌握OS设计实现：在1的基础上，能够通过编程完成lab_codes的8个lab实验中的基本练习和实验报告。 掌握OS核心功能：在2的基础上，能够通过编程完成lab_codes的8个lab实验中的challenge练习。 掌握OS科学研究：联系老师，加入实验室，开始科研吧。 友情提示 课程铺垫——计算机组成原理、C语言、数据结构 工具掌握——命令行 shell、软件管理 apt-get/aptitude、版本管理 git/github、代码阅读 understand/VSCode、代码比较 diff/meld、开发编译调试 gcc/gdb/make、硬件模拟器 qemu、md文档编写 Typora 实验报告要求 独立完成； 用Markdown语言编写； 报告内容包括但不仅限于：实验目的、实验内容、实验步骤、实验结果、遇到的问题与解决方法； 报告编写完需按时发送给助教并上传到自己的github仓库里。 维护者 kelee@mail.nankai.edu.cn 如若对本指导书有任何疑问，请联系维护者！ Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-29 11:32:54 "},"Lab0/":{"url":"Lab0/","title":"Lab0","keywords":"","body":"实验零：操作系统实验准备 主要学习先导知识与配置环境 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-14 12:59:15 "},"Lab0/实验目的.html":{"url":"Lab0/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 了解操作系统开发实验环境 熟悉命令行方式的编译、调试工程 掌握基于硬件模拟器的调试技术 熟悉C语言编程和指针的概念 了解RISCV-32汇编语言 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-22 17:09:28 "},"Lab0/准备知识.html":{"url":"Lab0/准备知识.html","title":"准备知识","keywords":"","body":"准备知识 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab0/了解OS实验.html":{"url":"Lab0/了解OS实验.html","title":"了解OS实验","keywords":"","body":"了解OS实验 写一个操作系统难吗？别被现在上百万行的Linux和Windows操作系统吓倒。当年Thompson趁他老婆带着小孩度假留他一人在家时，写了UNIX；当年Linus还是一个21岁大学生时完成了Linux雏形。站在这些巨人的肩膀上，我们能否也尝试一下做“巨人”的滋味呢？ MIT的Frans Kaashoek等在2006年参考PDP-11上的UNIX Version 6写了一个可在X86上跑的操作系统xv6（基于MIT License），用于学生学习操作系统。我们可以站在他们的肩膀上，基于xv6的设计，尝试着一步一步完成一个从“空空如也”到“五脏俱全”的“麻雀”操作系统——ucore，此“麻雀”包含虚存管理、进程管理、处理器调度、同步互斥、进程间通信、文件系统等主要内核功能，总的内核代码量（C+asm）不会超过5K行。充分体现了“小而全”的指导思想。 ucore的运行环境可以是真实的RISC-V计算机（小型，如智能手表），不过考虑到调试和开发的方便，我们可采用RISC-V硬件模拟器，比如QEMU、BOCHS、VirtualBox、VMware Player等。。ucore的开发环境主要是GCC中的gcc、gas、ld和MAKE等工具，在分析源代码上，可以采用Scitools提供的understand软件（跨平台）、VSCode（跨平台），windows环境上的source insight软件，或者基于emacs+ctags，vim+ctags等，都可以比较方便在在一堆文件中查找变量、函数定义、调用/访问关系等。软件开发的版本管理可以采用GIT、SVN等。比较文件和目录的不同可发现不同实验中的差异性和进行文件合并操作，可使用meld、kdiff3、UltraCompare等软件。调试（deubg）实验有助于发现设计中的错误，可采用gdb（配合qemu）等调试工具软件。并可整个实验的运行环境和开发环境在Linux环境中使用。 那我们准备如何一步一步来实现ucore呢？根据一个操作系统的设计实现过程，我们可以有如下的实验步骤： 启动操作系统的bootloader，用于了解操作系统启动前的状态和要做的准备工作，了解运行操作系统的硬件支持，操作系统如何加载到内存中，理解两类中断--“外设中断”，“陷阱中断”等； 物理内存管理子系统，用于理解RISC-V分段/分页模式，了解操作系统如何管理物理内存； 虚拟内存管理子系统，通过页表机制和换入换出（swap）机制，以及中断-“故障中断”、缺页故障处理等，实现基于页的内存替换算法； 内核线程子系统，用于了解如何创建相对与用户进程更加简单的内核态线程，如果对内核线程进行动态管理等； 用户进程管理子系统，用于了解用户态进程创建、执行、切换和结束的动态管理过程，了解在用户态通过系统调用得到内核态的内核服务的过程； 处理器调度子系统，用于理解操作系统的调度过程和调度算法； 同步互斥与进程间通信子系统，了解进程间如何进行信息交换和共享，并了解同步互斥的具体实现以及对系统性能的影响，研究死锁产生的原因，以及如何避免死锁； 文件系统，了解文件系统的具体实现，与进程管理等的关系，了解缓存对操作系统IO访问的性能改进，了解虚拟文件系统（VFS）、buffer cache和disk driver之间的关系。 其中每个开发步骤都是建立在上一个步骤之上的，就像搭积木，从一个一个小木块，最终搭出来一个小房子。在搭房子的过程中，完成从理解操作系统原理到实践操作系统设计与实现的探索过程。这个房子最终的建筑架构和建设进度如下图所示： Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-29 10:49:42 "},"Lab0/设置实验环境.html":{"url":"Lab0/设置实验环境.html","title":"设置实验环境","keywords":"","body":"设置实验环境 我们参考了MIT的xv6、Harvard的OS161和Linux等设计了ucore OS实验，所有OS实验需在Linux下运行。对于经验不足的同学，推荐参考“通过虚拟机使用Linux实验环境”一节用虚拟机方式进行试验。 [!NOTE|style:flat] 也有同学在MAC系统和Windows系统中搭建实验环境，不过过程相对比较复杂，这里就不展开介绍了。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-14 13:04:34 "},"Lab0/开发OS实验的简单步骤.html":{"url":"Lab0/开发OS实验的简单步骤.html","title":"开发OS实验的简单步骤","keywords":"","body":"开发OS实验的简单步骤 本次OS实验大致可以通过如下过程就可以完成使用： 学习相关理论知识 建立LAB实验环境，采用VMware虚拟机的最简单方式完成 阅读本LAB实验指导书，了解实验要求 下载源码 进入各个OS实验工程目录 例如：cd labcodes/lab1 根据实验要求阅读并修改代码 编译源码 例如执行：make 如果不通过则返回步骤3 如果实现不正确（即看到步骤6的输出存在不是OK的情况）则返回3 如果实现基本正确（即看到6的输出都是OK）则push到自己github仓库 编写实验报告，发送到助教邮箱，并push到github仓库 另外，可以通过make qemu让OS实验工程在qemu上运行；可以通过make debug或make debug-nox命令实现通过gdb远程调试 OS实验工程。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-29 11:42:12 "},"Lab0/通过虚拟机使用Linux实验环境.html":{"url":"Lab0/通过虚拟机使用Linux实验环境.html","title":"通过虚拟机使用Linux实验环境","keywords":"","body":"通过虚拟机使用Linux实验环境 通过虚拟机进行实验是最容易的实验环境安装方法，这也是最简单的一种通过虚拟机方式使用Linux并完成OS各个实验的方法。具体步骤如下： 首先下载并安装VMware15 客户端（VMware只支持Windows与Linux，MAC需要自己上网查找虚拟机安装教程）。 到清华镜像站下载Ubuntu 18.04.3 的镜像文件。 具体的安装步骤可参考这个教程。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-11 11:52:02 "},"Lab0/安装使用Linux实验环境.html":{"url":"Lab0/安装使用Linux实验环境.html","title":"安装使用Linux实验环境","keywords":"","body":"安装使用Linux实验环境 使用Linux 在实验过程中，我们需要了解基于命令行方式的编译、调试、运行操作系统的实验方法。为此，需要了解基本的Linux命令行使用。 命令模式的基本结构和概念 Ubuntu是图形界面友好和易操作的linux发行版，但有时只需执行几条简单的指令就可以完成繁琐的鼠标点击才能完成的操作。linux的命令行操作模式功能可以实现你需要的所有操作。简单的说，命令行就是基于字符命令的用户界面，也被称为文本操作模式。绝大多数情况下， 用户通过输入一行或多行命令直接与计算机互动，来实现对计算机的操作。 如何进入命令模式 假设使用默认的图形界面为GNOME的任意版本Ubuntu Linux。点击鼠标右键->终端，就可以启动名为terminal程序，从而可以在此软件界面中进行命令行操作。 打开terminal程序后你首先可能会注意到类似下面的界面： kelee@ubuntu:~$ 你所看到的这些被称为命令终端提示符，它表示计算机已就绪，正在等待着用户输入操作指令。以我的屏幕画面为例，“kelee\"是当前所登录的用户名，“ubuntu”是这台计算机的主机名，“~”表示当前目录。此时输入任何指令按回车之后该指令将会提交到计算机运行，比如你可以输入命令：ls 再按下回车： ls [ENTER] 注意：[ENTER]是指输入完ls后按下回车键，而不是叫你输入这个单词，ls这个命令将会列出你当前所在目录里的所有文件和子目录列表。 下面介绍bash shell程序的基本使用方法，它是ubuntu缺省的外壳程序。 常用指令 查询文件列表：(ls) kelee@ubuntu:~$ ls Desktop Downloads Music Public Templates Documents examples.desktop Pictures riscv Videos ls命令默认状态下将按首字母升序列出你当前文件夹下面的所有内容，但这样直接运行所得到的信息也是比较少的，通常它可以结合以下这些参数运行以查询更多的信息： ls / # 将列出根目录'/'下的文件清单.如果给定一个参数，则命令行会把该参数当作命令行的工作目录。换句话说，命令行不再以当前目录为工作目录。 ls -l # 将给你列出一个更详细的文件清单. ls -a # 将列出包括隐藏文件(以.开头的文件)在内的所有文 件. ]ls -h # 将以KB/MB/GB的形式给出文件大小,而不是以纯粹的Bytes. 查询当前所在目录：(pwd) kelee@ubuntu:~$ pwd /home/kelee 进入其他目录：(cd) kelee@ubuntu:~$ cd riscv kelee@ubuntu:~/riscv$ pwd /home/kelee/riscv kelee@ubuntu:~/riscv$ 上面例子中，当前目录原来是/home/kelee,执行cd riscv之后再运行pwd可以发现，当前目录已经改为/riscv了。 在屏幕上输出字符： (echo) kelee@ubuntu:~$ echo \"Hello World\" Hello World 这是一个很有用的命令，它可以在屏幕上输入你指定的参数(\"\"号中的内容)，当然这里举的这个例子中它没有多大的实际意义，但随着你对LINUX指令的不断深入，就会发现它的价值所在。 显示文件内容：cat kelee@ubuntu:~$ cat tempfile.txt Roses are red. Violets are blue, and you have the bird-flue! 也可以使用less或more来显示比较大的文本文件内容。 复制文件： cp kelee@ubuntu:~$ cp tempfile.txt tempfile_copy.txt kelee@ubuntu:~$ cat tempfile_copy.txt Roses are red. Violets are blue, and you have the bird-flue! 移动文件：mv kelee@ubuntu:~$ ls Desktop Downloads Music Public tempfile_copy.txt Templates Documents examples.desktop Pictures riscv tempfile.txt Videos kelee@ubuntu:~$ mv tempfile_copy.txt tempfile_mv.txt kelee@ubuntu:~$ ls Desktop Downloads Music Public tempfile_mv.txt Templates Documents examples.desktop Pictures riscv tempfile.txt Videos 注意：在命令操作时系统基本上不会给你什么提示，当然，绝大多数的命令可以通过加上一个参数-v来要求系统给出执行命令的反馈信息； kelee@ubuntu:~$ mv -v tempfile_mv.txt tempfile_mv_v.txt renamed 'tempfile_mv.txt' -> 'tempfile_mv_v.txt' 建立一个空文本文件：touch kelee@ubuntu:~$ ls Desktop Downloads Music Public tempfile_mv_v.txt Templates Documents examples.desktop Pictures riscv tempfile.txt Videos kelee@ubuntu:~$ touch file1.txt kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt Videos Documents file1.txt Public tempfile.txt Downloads Music riscv Templates 建立一个目录：mkdir kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt Videos Documents file1.txt Public tempfile.txt Downloads Music riscv Templates kelee@ubuntu:~$ mkdir test_dir kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt test_dir Documents file1.txt Public tempfile.txt Videos Downloads Music riscv Templates 删除文件/目录：rm kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt test_dir Documents file1.txt Public tempfile.txt Videos Downloads Music riscv Templates kelee@ubuntu:~$ rm tempfile_mv_v.txt kelee@ubuntu:~$ ls -p Desktop/ examples.desktop Pictures/ tempfile.txt Videos/ Documents/ file1.txt Public/ Templates/ Downloads/ Music/ riscv/ test_dir/ kelee@ubuntu:~$ rm test_dir rm: cannot remove 'test_dir': Is a directory kelee@ubuntu:~$ rm -R test_dir kelee@ubuntu:~$ ls Desktop Downloads file1.txt Pictures riscv Templates Documents examples.desktop Music Public tempfile.txt Videos 在上面的操作：首先我们通过ls命令查询可知当前目下有两个文件和一个文件夹； [1] 你可以用参数 -p来让系统显示某一项的类型，比如是文件/文件夹/快捷链接等等； [2] 接下来我们用rm -i尝试删除文件，-i参数是让系统在执行删除操作前输出一条确认提示；i(interactive)也就是交互性的意思； [3] 当我们尝试用上面的命令去删除一个文件夹时会得到错误的提示，因为删除文件夹必须使用-R(recursive,循环）参数 特别提示：在使用命令操作时，系统假设你很明确自己在做什么，它不会给你太多的提示，比如你执行rm -Rf /，它将会删除你硬盘上所有的东西，并且不会给你任何提示，所以，尽量在使用命令时加上-i的参数，以让系统在执行前进行一次确认，防止你干一些蠢事。如 果你觉得每次都要输入-i太麻烦，你可以执行以下的命令，让－i成为默认参数： alias rm='rm -i' 查询当前进程：ps kelee@ubuntu:~$ ps PID TTY TIME CMD 3356 pts/0 00:00:00 bash 3659 pts/0 00:00:00 ps 这条命令会例出你所启动的所有进程； ps -a #可以例出系统当前运行的所有进程，包括由其他用户启动的进程； ps auxww #是一条相当人性化的命令，它会例出除一些很特殊进程以外的所有进程，并会以一个高可读的形式显示结果，每一个进程都会有较为详细的解释； 基本命令的介绍就到此为止，你可以访问网络得到更加详细的Linux命令介绍。 控制流程 输入/输出 input用来读取你通过键盘（或其他标准输入设备）输入的信息，output用于在屏幕（或其他标准输出设备）上输出你指定的输出内容.另外还有一些标准的出错提示也是通过这个命令来实现的。通常在遇到操作错误时，系统会自动调用这个命令来输出标准错误提示； 我们能重定向命令中产生的输入和输出流的位置。 重定向 如果你想把命令产生的输出流指向一个文件而不是（默认的）终端，你可以使用如下的语句： kelee@ubuntu:~$ ls >file2.txt kelee@ubuntu:~$ cat file2.txt Desktop Documents Downloads examples.desktop file1.txt file2.txt Music Pictures Public riscv tempfile.txt Templates Videos 以上例子将创建文件file2.txt如果file2.txt不存在的话。注意：如果file2.txt已经存在，那么上面的命令将复盖文件的内容。如果你想将内容添加到已存在的文件内容的最后，那你可以用下面这个语句： command >> filename 示例: kelee@ubuntu:~$ ls >>file2.txt kelee@ubuntu:~$ cat file2.txt Desktop Documents Downloads examples.desktop file1.txt file2.txt Music Pictures Public riscv tempfile.txt Templates Videos Desktop Documents Downloads examples.desktop file1.txt file2.txt Music Pictures Public riscv tempfile.txt Templates Videos 在这个例子中，你会发现原有的文件中添加了新的内容。接下来我们会见到另一种重定向方式：我们将把一个文件的内容作为将要执行的命令的输入。以下是这个语句： command 示例: kelee@ubuntu:~$ sort 管道 Linux的强大之处在于它能把几个简单的命令联合成为复杂的功能，通过键盘上的管道符号'|' 完成。现在，我们来排序上面的\"grep\"命令： kelee@ubuntu:~$ grep -i 'D' result.txt kelee@ubuntu:~$ cat result.txt Desktop Desktop Documents Documents Downloads Downloads examples.desktop examples.desktop Videos Videos 搜索 file2.txt 中的d字母，将输出分类并写入分类文件到 result.txt 。 有时候用ls列出很多命令的时候很不方便 这时“｜”就充分利用到了 ls -l | less 慢慢看吧. 后台进程 CLI 不是系统的串行接口。您可以在执行其他命令时给出系统命令。要启动一个进程到后台，追加一个“&”到命令后面。 sleep 60 & ls 睡眠命令在后台运行，您依然可以与计算机交互。除了不同步启动命令以外，最好把 '&' 理解成 ';'。 如果您有一个命令将占用很多时间，您想把它放入后台运行，也很简单。只要在命令运行时按下ctrl-z，它就会停止。然后键入 bg使其转入后台。fg 命令可使其转回前台。 sleep 60 # 这表示敲入Ctrl+Z键 bg fg 最后，您可以使用 ctrl-c 来杀死一个前台进程。 环境变量 特殊变量。PATH, PS1, ... 不显示中文 可通过执行如下命令避免显示乱码中文。在一个shell中，执行： export LANG=”” 这样在这个shell中，output信息缺省时英文。 获得软件包 命令行获取软件包 Ubuntu 下可以使用 apt-get 命令，apt-get 是一条 Linux 命令行命令，适用于 deb 包管理式的操作系统，主要用于自动从互联网软件库中搜索、安装、升级以及卸载软件或者操作系统。一般需要 root 执行权限，所以一般跟随 sudo 命令，如： sudo apt-get install gcc [ENTER] 常见的以及常用的 apt 命令有： apt-get install 下载 以及所依赖的软件包，同时进行软件包的安装或者升级。 apt-get remove 移除 以及所有依赖的软件包。 apt-cache search 搜索满足 的软件包。 apt-cache show/showpkg 显示软件包 的完整描述。 例如： kelee@ubuntu:~$ apt-cache search aptitude aptitude - terminal-based package manager aptitude-common - architecture independent files for the aptitude package manager aptitude-doc-en - English manual for aptitude, a terminal-based package manager libcwidget-dev - high-level terminal interface library for C++ (development files) apt-cacher - Caching proxy server for Debian/Ubuntu software repositories apticron - Simple tool to mail about pending package updates - cron version apticron-systemd - Simple tool to mail about pending package updates - systemd version aptitude-doc-cs - Czech manual for aptitude, a terminal-based package manager aptitude-doc-es - Spanish manual for aptitude, a terminal-based package manager aptitude-doc-fi - Finnish manual for aptitude, a terminal-based package manager aptitude-doc-fr - French manual for aptitude, a terminal-based package manager aptitude-doc-it - Italian manual for aptitude, a terminal-based package manager aptitude-doc-ja - Japanese manual for aptitude, a terminal-based package manager aptitude-doc-nl - Dutch manual for aptitude, a terminal-based package manager aptitude-doc-ru - Russian manual for aptitude, a terminal-based package manager aptitude-robot - Automate package choice management cron-apt - automatic update of packages using apt-get cupt - flexible package manager -- console interface gbrainy - brain teaser game and trainer to have fun and to keep your brain trained pkgsync - automated package list synchronization wajig - unified package management front-end for Debian kelee@ubuntu:~$ 配置升级源 Ubuntu的软件包获取依赖升级源，通过Software&Updates->Ubuntu Software->Download from:->Other:->China->mirrors.aliyun.com->Choose Server 查找帮助文件 Ubuntu 下提供 man 命令以完成帮助手册得查询。man 是 manual 的缩写，通过 man 命令可以对 Linux 下常用命令、安装软件、以及C语言常用函数等进行查询，获得相关帮助。 例如： kelee@ubuntu:~$ man printf PRINTF(1) User Commands PRINTF(1) NAME printf - format and print data SYNOPSIS printf FORMAT [ARGUMENT]... printf OPTION DESCRIPTION Print ARGUMENT(s) according to FORMAT, or execute according to OPTION: --help display this help and exit --version output version information and exit FORMAT controls the output as in C printf. Interpreted sequences are: \\\" double quote \\\\ backslash Manual page printf(1) line 1 (press h for help or q to quit) 通常可能会用到的帮助文件例如： gcc-doc cpp-doc glibc-doc 上述帮助文件可以通过 apt-get 命令或者软件包管理器获得。获得以后可以通过 man 命令进行命令或者参数查询。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-04 11:49:28 "},"Lab0/实验中可能使用的软件.html":{"url":"Lab0/实验中可能使用的软件.html","title":"实验中可能使用的软件","keywords":"","body":"实验中可能使用的软件 编辑器 自带的编辑器 Ubuntu 下自带的编辑器可以作为代码编辑的工具。例如 gedit 是 gnome 桌面环境下兼容UTF-8的文本编辑器。它十分的简单易用，有良好的语法高亮，对中文支持很好。通常可以通过双击或者命令行打开目标文件进行编辑。 Vim 编辑器 Vim是一款极方便的文本编辑软件，是UNIX下的同类型软件VI的改进版本。Vim经常被看作是“专门为程序员打造的文本编辑器”，功能强大且方便使用，便于进行程序开发。 Ubuntu 下默认安装的 vi 版本较低，功能较弱，建议在系统内安装或者升级到最新版本的 Vim。 关于Vim的常用命令以及使用，可以通过网络进行查找。 配置文件：Vim 的使用需要配置文件进行设置，例如： set nocompatible set encoding=utf-8 set fileencodings=utf-8,chinese set tabstop=4 set cindent shiftwidth=4 set backspace=indent,eol,start autocmd Filetype c set omnifunc=ccomplete#Complete autocmd Filetype cpp set omnifunc=cppcomplete#Complete set incsearch set number set display=lastline set ignorecase syntax on set nobackup set ruler set showcmd set smartindent set hlsearch set cmdheight=1 set laststatus=2 set shortmess=atI set formatoptions=tcrqn set autoindent 可以将上述配置文件保存到： ~/.vimrc 注意：.vimrc 默认情况下隐藏不可见，可以在命令行中通过 “ls -a” 命令进行查看。如果 '~' 目录下不存在该文件，可以手动创建。修改该文件以后，重启 Vim 可以使配置生效。 VScode VScode是很好的项目管理、代码编译器工具，集成了git，并且可以安装各类插件支持各种语言，习惯使用visual studio的同学使用起来会非常习惯，具体的下载安装使用方法，可以参考该教程，值得说明的是，我们在编译的时候需要其他工具联合编译，因此可以仅仅把VScode当成没有感情的写代码工具，不由它来编译运行，编译运行交给终端。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-10 11:38:20 "},"Lab0/了解编程开发调试的基本工具.html":{"url":"Lab0/了解编程开发调试的基本工具.html","title":"了解编程开发调试的基本工具","keywords":"","body":"了解编程开发调试的基本工具 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/gcc的基本用法.html":{"url":"Lab0/gcc的基本用法.html","title":"gcc的基本用法","keywords":"","body":"gcc的基本用法 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/编译简单的 C 程序.html":{"url":"Lab0/编译简单的 C 程序.html","title":"编译简单的 C 程序","keywords":"","body":"编译简单的 C 程序 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/AT&T汇编基本语法.html":{"url":"Lab0/AT&T汇编基本语法.html","title":"AT&T汇编基本语法","keywords":"","body":"AT&T汇编基本语法 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/GCC基本内联汇编.html":{"url":"Lab0/GCC基本内联汇编.html","title":"GCC基本内联汇编","keywords":"","body":"GCC基本内联汇编 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/GCC扩展内联汇编.html":{"url":"Lab0/GCC扩展内联汇编.html","title":"GCC扩展内联汇编","keywords":"","body":"GCC扩展内联汇编 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/make和Makefile.html":{"url":"Lab0/make和Makefile.html","title":"make和Makefile","keywords":"","body":"make和Makefile Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/gdb使用.html":{"url":"Lab0/gdb使用.html","title":"gdb使用","keywords":"","body":"gdb使用 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/进一步的相关内容.html":{"url":"Lab0/进一步的相关内容.html","title":"进一步的相关内容","keywords":"","body":"进一步的相关内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/基于硬件模拟器实现源码级调试.html":{"url":"Lab0/基于硬件模拟器实现源码级调试.html","title":"基于硬件模拟器实现源码级调试","keywords":"","body":"基于硬件模拟器实现源码级调试 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/安装硬件模拟器QEMU.html":{"url":"Lab0/安装硬件模拟器QEMU.html","title":"安装硬件模拟器QEMU","keywords":"","body":"安装硬件模拟器QEMU Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/Linux运行环境.html":{"url":"Lab0/Linux运行环境.html","title":"Linux运行环境","keywords":"","body":"Linux运行环境 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/Linux环境下的源码级安装过程.html":{"url":"Lab0/Linux环境下的源码级安装过程.html","title":"Linux环境下的源码级安装过程","keywords":"","body":"Linux环境下的源码级安装过程 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/获得并应用修改.html":{"url":"Lab0/获得并应用修改.html","title":"获得并应用修改","keywords":"","body":"获得并应用修改 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/配置、编译和安装.html":{"url":"Lab0/配置、编译和安装.html","title":"配置、编译和安装","keywords":"","body":"配置、编译和安装 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/使用硬件模拟器QEMU.html":{"url":"Lab0/使用硬件模拟器QEMU.html","title":"使用硬件模拟器QEMU","keywords":"","body":"使用硬件模拟器QEMU Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/运行参数.html":{"url":"Lab0/运行参数.html","title":"运行参数","keywords":"","body":"运行参数 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/常用调试命令.html":{"url":"Lab0/常用调试命令.html","title":"常用调试命令","keywords":"","body":"常用调试命令 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/结合gdb和qemu源码级调试ucore.html":{"url":"Lab0/结合gdb和qemu源码级调试ucore.html","title":"结合gdb和qemu源码级调试ucore","keywords":"","body":"结合gdb和qemu源码级调试ucore Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/编译可调试的目标文件.html":{"url":"Lab0/编译可调试的目标文件.html","title":"编译可调试的目标文件","keywords":"","body":"编译可调试的目标文件 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/ucore 代码编译.html":{"url":"Lab0/ucore 代码编译.html","title":"ucore 代码编译","keywords":"","body":"ucore 代码编译 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/使用远程调试.html":{"url":"Lab0/使用远程调试.html","title":"使用远程调试","keywords":"","body":"使用远程调试 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/使用gdb配置文件.html":{"url":"Lab0/使用gdb配置文件.html","title":"使用gdb配置文件","keywords":"","body":"使用gdb配置文件 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/加载调试目标.html":{"url":"Lab0/加载调试目标.html","title":"加载调试目标","keywords":"","body":"加载调试目标 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/设定调试目标架构.html":{"url":"Lab0/设定调试目标架构.html","title":"设定调试目标架构","keywords":"","body":"设定调试目标架构 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/了解处理器硬件.html":{"url":"Lab0/了解处理器硬件.html","title":"了解处理器硬件","keywords":"","body":"了解处理器硬件 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/RISC-V32运行模式.html":{"url":"Lab0/RISC-V32运行模式.html","title":"RISC-V32运行模式","keywords":"","body":"RISC-V32运行模式 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/RISC-V32内存架构.html":{"url":"Lab0/RISC-V32内存架构.html","title":"RISC-V32内存架构","keywords":"","body":"RISC-V32内存架构 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/RISC-V32寄存器.html":{"url":"Lab0/RISC-V32寄存器.html","title":"RISC-V32寄存器","keywords":"","body":"RISC-V32寄存器 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/了解ucore编程方法和通用数据结构.html":{"url":"Lab0/了解ucore编程方法和通用数据结构.html","title":"了解ucore编程方法和通用数据结构","keywords":"","body":"了解ucore编程方法和通用数据结构 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/面向对象编程方法.html":{"url":"Lab0/面向对象编程方法.html","title":"面向对象编程方法","keywords":"","body":"面向对象编程方法 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/通用数据结构.html":{"url":"Lab0/通用数据结构.html","title":"通用数据结构","keywords":"","body":"通用数据结构 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/双向循环链表.html":{"url":"Lab0/双向循环链表.html","title":"双向循环链表","keywords":"","body":"双向循环链表 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/附录A：ucore实验中的常用工具.html":{"url":"Lab0/附录A：ucore实验中的常用工具.html","title":"附录A：ucore实验中的常用工具","keywords":"","body":"附录A：ucore实验中的常用工具 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab0/附录B：ucore实验参考资料.html":{"url":"Lab0/附录B：ucore实验参考资料.html","title":"附录B：ucore实验参考资料","keywords":"","body":"附录B：ucore实验参考资料 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-27 22:41:13 "},"Lab1/":{"url":"Lab1/","title":"Lab1","keywords":"","body":"Lab1 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab1/实验目的.html":{"url":"Lab1/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab1/实验内容.html":{"url":"Lab1/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab2/":{"url":"Lab2/","title":"Lab2","keywords":"","body":"Lab2 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab2/实验目的.html":{"url":"Lab2/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab2/实验内容.html":{"url":"Lab2/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab3/":{"url":"Lab3/","title":"Lab3","keywords":"","body":"Lab3 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab3/实验目的.html":{"url":"Lab3/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab3/实验内容.html":{"url":"Lab3/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab4/":{"url":"Lab4/","title":"Lab4","keywords":"","body":"Lab4 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab4/实验目的.html":{"url":"Lab4/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab4/实验内容.html":{"url":"Lab4/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab5/":{"url":"Lab5/","title":"Lab5","keywords":"","body":"Lab5 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab5/实验目的.html":{"url":"Lab5/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab5/实验内容.html":{"url":"Lab5/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab6/":{"url":"Lab6/","title":"Lab6","keywords":"","body":"Lab6 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab6/实验目的.html":{"url":"Lab6/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab6/实验内容.html":{"url":"Lab6/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab7/":{"url":"Lab7/","title":"Lab7","keywords":"","body":"Lab7 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab7/实验目的.html":{"url":"Lab7/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab7/实验内容.html":{"url":"Lab7/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab8/":{"url":"Lab8/","title":"Lab8","keywords":"","body":"Lab8 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab8/实验目的.html":{"url":"Lab8/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab8/实验内容.html":{"url":"Lab8/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "}}