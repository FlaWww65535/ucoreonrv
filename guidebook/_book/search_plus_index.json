{"./":{"url":"./","title":"Introduction","keywords":"","body":"uCore OS(on RISC-V32)实验指导书 ucore实验指导书 ucore labs 1-8 源码和参考答案 实验总体流程 认真上操作系统的理论课程； 阅读ucore实验指导书，并参考其内容完成联系和实验报告; 在实验环境中完成实验并提交到自己的github上； 遇到问题，首先查询手册等其他资料，先自行解决； 如若不能解决，可在飞书群里提问，可以互相讨论，有助教老师答疑。 学习目标与对应手段 掌握OS基本概念：通过上课与学习教材，能理解OS原理与概念；阅读指导书并分析源码，能理解lab_codes_answer的labs运行结果。 掌握OS设计实现：在1的基础上，能够通过编程完成lab_codes的8个lab实验中的基本练习和实验报告。 掌握OS核心功能：在2的基础上，能够通过编程完成lab_codes的8个lab实验中的challenge练习。 掌握OS科学研究：联系老师，加入实验室，开始科研吧。 友情提示 课程铺垫——计算机组成原理、C语言、数据结构 工具掌握——命令行 shell、软件管理 apt-get/aptitude、版本管理 git/github、代码阅读 understand/VSCode、代码比较 diff/meld、开发编译调试 gcc/gdb/make、硬件模拟器 qemu、md文档编写 Typora 实验报告要求 独立完成； 用Markdown语言编写； 报告内容包括但不仅限于：实验目的、实验内容、实验步骤、实验结果、遇到的问题与解决方法； 报告编写完需按时发送给助教并上传到自己的github仓库里。 维护者 kelee@mail.nankai.edu.cn 如若对本指导书有任何疑问，请联系维护者！ Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:14:09 "},"Lab0/":{"url":"Lab0/","title":"LAB0","keywords":"","body":"LAB0：操作系统实验准备 学习与操作系统实验相关的前导知识，其主要包括实验环境、实验步骤、实验工具、uCore历史、RISC-V简介。 配置实验所需要的环境与软件。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:19:50 "},"Lab0/实验目的.html":{"url":"Lab0/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 了解操作系统开发实验环境 学会使用Ubuntu操作系统 熟悉命令行方式的编译、调试工程 掌握基于硬件模拟器的调试技术 学会使用基本的开发工具 掌握RISCV-32汇编语言 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:22:13 "},"Lab0/实验内容.html":{"url":"Lab0/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 阅读实验指导书内容以及涉及的官方文档或者教程。 对于实验指导书未涉及的内容能自行动手查询资料学习。 安装Ubuntu操作系统。 安装推荐的开发工具，若对某些工具情有独钟亦可。 安装依赖包、硬件模拟器、调试工具后尝试进行联合调试。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:49:03 "},"Lab0/前导知识.html":{"url":"Lab0/前导知识.html","title":"前导知识","keywords":"","body":"前导知识 该模块是LAB0的第一个模块，主要就是阅读学习相关的知识，对OS实验有一个基本的了解，看一下我们接下来一个学期到底要做什么，要实现什么样的一个东西，而这个东西又是基于什么基础慢慢搭建起来的。要搭建房子需要各种工具，工欲善其事必先利其器，所以要学会使用主要的开发调试工具，能让我们实验过程变得非常愉快。 最后由于我们是基于RISC-V指令集来完成实验，当然要掌握这门指令集的所有东西啦，幸运的是，你选择的是最简单的指令集，有没有开心一点呢？ [!NOTE|style:flat] 千万不要嫌接下来的前导知识杂没有用哦，答应我，一定要认认真真的看哈~ Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 12:43:57 "},"Lab0/前导知识/了解uCore.html":{"url":"Lab0/前导知识/了解uCore.html","title":"了解uCore","keywords":"","body":"了解uCore 2006年, MIT的Frans Kaashoek等人参考PDP-11上的UNIX Version 6写了一个可在x86指令集架构上运行的操作系统xv6（基于MIT License)。 2010年, 清华大学操作系统教学团队参考MIT的教学操作系统xv6, 开发了在x86指令集架构上运行的操作系统ucore, 多年来作为操作系统课程的实验框架使用, 已经成为了大家口中的\"祖传实验\". ucore麻雀虽小，五脏俱全。在不超过5k的代码量中包含虚拟内存管理、进程管理、处理器调度、同步互斥、进程间通信、文件系统等主要内核功能，充分体现了“小而全”的指导思想。 ucore的运行环境可以是真实的计算机（包括小型智能设备）。一开始ucore是运行在x86指令集架构上的，到了如今，x86指令集架构的问题渐渐开始暴露出来。 虽然在PC平台上占据绝对主流，但出于兼容性考虑x86架构仍然保留了许多的历史包袱，用于教学的时候总有些累赘。另一方面，为了更好的和目前5G、物联网技术的发展衔接，将ucore移植到RISC-V架构势在必行。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-16 11:19:34 "},"Lab0/前导知识/了解RISC-V.html":{"url":"Lab0/前导知识/了解RISC-V.html","title":"了解RISC-V","keywords":"","body":"了解RISC-V 发明 RISC发明者是美国加州大学伯克利分校教师David Patterson，RISC-V（拼做risk-five）是第五代精简指令集，也是由David Patterson指导的项目。2010年伯克利大学并行计算实验室(Par Lab) 的1位教授和2个研究生想要做一个项目，需要选一种计算机架构来做。当时面临的的是选择X86、ARM，还是其他指令集，不管选择哪个都或多或少有些问题，比如授权费价格高昂，不能开源，不能扩展更改等等。所以他们在2010年5月开始规划自己做一个新的、开源的指令集，就是RISC-V。 接着时间到2015年，这个指令集在学术界已经开始出名了，这时为了更好的推动这个指令集在技术和商业上的发展，3位创始人大佬做了下面两件事情。 技术方向，成立RISC-V基金会，维护指令集架构的完整性和非碎片化。 商业方向，成立SiFive公司，推动RISC-V的商业化。 基金会会员 目前加入RISC-V基金会的中国企业和机构有：阿里巴巴、华为、中科院计算所、华米科技、智芯科技、浪潮等。（具体会员名单可以在这里查看） 特点 设计哲学-简单就是美 无病一身轻——架构的篇幅。目前的“RISC-V架构文档”分为“指令集文档”（riscv-spec-v2.2.pdf）和“特权架构文档”（riscv-privileged-v1.10.pdf）。“指令集文档”的篇幅为145页，而“特权架构文档”的篇幅也仅为91页。熟悉体系结构的工程师仅需一至两天便可将其通读，虽然“RISC-V的手册”还在不断地丰富，但是相比“x86的架构文档”与“ARM的架构文档”，RISC-V的篇幅可以说是极其短小精悍。 [!NOTE|style:flat] 一定要仔细阅读《RISC-V手册》哦！！ 能屈能伸——模块化的指令集。RISC-V架构相比其他成熟的商业架构的最大一个不同还在于它是一个模块化的架构。因此，RISC-V架构不仅短小精悍，而且其不同的部分还能以模块化的方式组织在一起，从而试图通过一套统一的架构满足各种不同的应用。这种模块化是x86与ARM架构所不具备的。以ARM的架构为例，ARM的架构分为A、R和M三个系列，分别针对于Application（应用操作系统）、Real-Time（实时）和Embedded（嵌入式）三个领域，彼此之间并不兼容。模块化的RISC-V架构能够使得用户能够灵活选择不同的模块组合，以满足不同的应用场景，可以说是“老少咸宜” 浓缩的都是精华——指令的数量。短小精悍的架构以及模块化的哲学，使得RISC-V架构的指令数目非常的简洁。基本的RISC-V指令数目仅有40多条，加上其他的模块化扩展指令总共几十条指令。 指令集简介 模块化的指令子集。RISC-V的指令集使用模块化的方式进行组织，每一个模块使用一个英文字母来表示。RISC-V最基本也是唯一强制要求实现的指令集部分是由I字母表示的基本整数指令子集，使用该整数指令子集，便能够实现完整的软件编译器。其他的指令子集部分均为可选的模块，具有代表性的模块包括M/A/F/D/C。 规整的指令编码。RISC-V的指令集编码非常的规整，指令所需的通用寄存器的索引（Index）都被放在固定的位置。因此指令译码器（Instruction Decoder）可以非常便捷的译码出寄存器索引然后读取通用寄存器组（Register File，Regfile）。 优雅的压缩指令子集。基本的RISC-V基本整数指令子集（字母I表示 ）规定的指令长度均为等长的32位，这种等长指令定义使得仅支持整数指令子集的基本RISC-V CPU非常容易设计。但是等长的32位编码指令也会造成代码体积（Code Size）相对较大的问题。为了满足某些对于代码体积要求较高的场景（譬如嵌入式领域），RISC-V定义了一种可选的压缩（Compressed）指令子集，由字母C表示，也可以由RVC表示。RISC-V具有后发优势，从一开始便规划了压缩指令，预留了足够的编码空间，16位长指令与普通的32位长指令可以无缝自由地交织在一起，处理器也没有定义额外的状态。 特权模式。RISC-V架构定义了三种工作模式，又称特权模式（Privileged Mode）：Machine Mode：机器模式，简称M Mode。Supervisor Mode：监督模式，简称S Mode。User Mode：用户模式，简称U Mode。RISC-V架构定义M Mode为必选模式，另外两种为可选模式。通过不同的模式组合可以实现不同的系统。 自定制指令扩展。除了上述阐述的模块化指令子集的可扩展、可选择，RISC-V架构还有一个非常重要的特性，那就是支持第三方的扩展。用户可以扩展自己的指令子集，RISC-V预留了大量的指令编码空间用于用户的自定义扩展，同时，还定义了四条Custom指令可供用户直接使用，每条Custom指令都有几个比特位的子编码空间预留，因此，用户可以直接使用四条Custom指令扩展出几十条自定义的指令。 其他特点 可配置的通用寄存器组、简洁的存储器访问指令、高效的分支跳转指令、简洁的子程序调用、无条件码执行、无分支延迟槽、简洁的运算指令。 [!TIP|style:flat|label:友情链接] RISC-V基金会 中国开放指令生态（RISC-V）联盟 赛昉科技 终于有人把RISC-V讲明白了 什么是RISC-V Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-18 11:12:17 "},"Lab0/前导知识/了解OS实验.html":{"url":"Lab0/前导知识/了解OS实验.html","title":"了解OS实验","keywords":"","body":"了解OS实验 写一个操作系统难吗？别被现在上百万行的Linux和Windows操作系统吓倒。当年Thompson趁他老婆带着小孩度假留他一人在家时，写了UNIX；当年Linus还是一个21岁大学生时完成了Linux雏形。站在这些巨人的肩膀上，我们能否也尝试一下做“巨人”的滋味呢？ 实验内容 那我们准备如何一步一步来实现ucore呢？根据一个操作系统的设计实现过程，我们可以有如下的实验步骤： 启动操作系统的bootloader:OpenSBI。了解操作系统启动前的状态和要做的准备工作，了解运行操作系统的硬件支持，操作系统如何加载到内存中，理解两类中断--“外设中断”，“陷阱中断”等； 物理内存管理子系统。用于理解RISC-V分段/分页模式，了解操作系统如何管理物理内存； 虚拟内存管理子系统。通过页表机制和换入换出（swap）机制，以及中断-“故障中断”、缺页故障处理等，实现基于页的内存替换算法； 内核线程子系统。用于了解如何创建相对与用户进程更加简单的内核态线程，如果对内核线程进行动态管理等； 用户进程管理子系统。用于了解用户态进程创建、执行、切换和结束的动态管理过程，了解在用户态通过系统调用得到内核态的内核服务的过程； 处理器调度子系统。用于理解操作系统的调度过程和调度算法； 同步互斥与进程间通信子系统。了解进程间如何进行信息交换和共享，并了解同步互斥的具体实现以及对系统性能的影响，研究死锁产生的原因，以及如何避免死锁； 文件系统。了解文件系统的具体实现，与进程管理等的关系，了解缓存对操作系统IO访问的性能改进，了解虚拟文件系统（VFS）、buffer cache和disk driver之间的关系。 其中每个开发步骤都是建立在上一个步骤之上的，就像搭积木，从一个一个小木块，最终搭出来一个小房子。在搭房子的过程中，完成从理解操作系统原理到实践操作系统设计与实现的探索过程。这个房子最终的建筑架构和建设进度如下图所示： 开发OS实验的步骤 本次OS实验大致可以通过如下过程就可以完成使用： 学习相关理论知识 建立LAB实验环境，采用VMware虚拟机的最简单方式完成 阅读本LAB实验指导书，了解实验要求 下载源码 进入各个OS实验工程目录 例如：cd labcodes/lab1 根据实验要求阅读并修改代码 编译源码 例如执行：make 如果不通过则返回步骤3 如果实现不正确（即看到步骤6的输出存在不是OK的情况）则返回3 如果实现基本正确（即看到6的输出都是OK）则push到自己github仓库 编写实验报告，发送到助教邮箱，并push到github仓库 [!NOTE|style:flat] 可以通过make qemu让OS实验工程在qemu上运行；可以通过make debug或make debug-nox命令实现通过gdb远程调试 OS实验工程。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-18 10:46:31 "},"Lab0/前导知识/了解实验环境.html":{"url":"Lab0/前导知识/了解实验环境.html","title":"了解实验环境","keywords":"","body":"了解实验环境 在实验中，我们使用的系统环境是Ubuntu18.04。在实验过程中，我们需要了解基于命令行方式的编译、调试、运行操作系统的实验方法。为此，需要了解基本的Linux命令行使用。 [!TIP|style:flat] 当然现在只是了解一下，具体的操作还是要在安装好虚机以后再来哦~ 命令模式的基本结构和概念 Ubuntu是图形界面友好和易操作的Linux发行版，但有时只需执行几条简单的指令就可以完成繁琐的鼠标点击才能完成的操作。Linux的命令行操作模式功能可以实现你需要的所有操作。简单的说，命令行就是基于字符命令的用户界面，也被称为文本操作模式。绝大多数情况下， 用户通过输入一行或多行命令直接与计算机互动，来实现对计算机的操作。 如何进入命令模式 假设使用默认的图形界面为GNOME的任意版本Ubuntu Linux。点击鼠标右键->终端，就可以启动名为terminal程序，从而可以在此软件界面中进行命令行操作。 打开terminal程序后你首先可能会注意到类似下面的界面： kelee@ubuntu:~$ 你所看到的这些被称为命令终端提示符，它表示计算机已就绪，正在等待着用户输入操作指令。以我的屏幕画面为例，“kelee\"是当前所登录的用户名，“ubuntu”是这台计算机的主机名，“~”表示当前目录。此时输入任何指令按回车之后该指令将会提交到计算机运行，比如你可以输入命令：ls 再按下回车： ls [ENTER] 注意：[ENTER]是指输入完ls后按下回车键，而不是叫你输入这个单词，ls这个命令将会列出你当前所在目录里的所有文件和子目录列表。 下面介绍bash shell程序的基本使用方法，它是ubuntu缺省的外壳程序。 常用指令 查询文件列表：(ls) kelee@ubuntu:~$ ls Desktop Downloads Music Public Templates Documents examples.desktop Pictures riscv Videos ls命令默认状态下将按首字母升序列出你当前文件夹下面的所有内容，但这样直接运行所得到的信息也是比较少的，通常它可以结合以下这些参数运行以查询更多的信息： ls / # 将列出根目录'/'下的文件清单.如果给定一个参数，则命令行会把该参数当作命令行的工作目录。换句话说，命令行不再以当前目录为工作目录。 ls -l # 将给你列出一个更详细的文件清单. ls -a # 将列出包括隐藏文件(以.开头的文件)在内的所有文 件. ]ls -h # 将以KB/MB/GB的形式给出文件大小,而不是以纯粹的Bytes. 查询当前所在目录：(pwd) kelee@ubuntu:~$ pwd /home/kelee 进入其他目录：(cd) kelee@ubuntu:~$ cd riscv kelee@ubuntu:~/riscv$ pwd /home/kelee/riscv kelee@ubuntu:~/riscv$ 上面例子中，当前目录原来是/home/kelee,执行cd riscv之后再运行pwd可以发现，当前目录已经改为/riscv了。 在屏幕上输出字符： (echo) kelee@ubuntu:~$ echo \"Hello World\" Hello World 这是一个很有用的命令，它可以在屏幕上输入你指定的参数(\"\"号中的内容)，当然这里举的这个例子中它没有多大的实际意义，但随着你对LINUX指令的不断深入，就会发现它的价值所在。 显示文件内容：cat kelee@ubuntu:~$ cat tempfile.txt Roses are red. Violets are blue, and you have the bird-flue! 也可以使用less或more来显示比较大的文本文件内容。 复制文件： cp kelee@ubuntu:~$ cp tempfile.txt tempfile_copy.txt kelee@ubuntu:~$ cat tempfile_copy.txt Roses are red. Violets are blue, and you have the bird-flue! 移动文件：mv kelee@ubuntu:~$ ls Desktop Downloads Music Public tempfile_copy.txt Templates Documents examples.desktop Pictures riscv tempfile.txt Videos kelee@ubuntu:~$ mv tempfile_copy.txt tempfile_mv.txt kelee@ubuntu:~$ ls Desktop Downloads Music Public tempfile_mv.txt Templates Documents examples.desktop Pictures riscv tempfile.txt Videos 注意：在命令操作时系统基本上不会给你什么提示，当然，绝大多数的命令可以通过加上一个参数-v来要求系统给出执行命令的反馈信息； kelee@ubuntu:~$ mv -v tempfile_mv.txt tempfile_mv_v.txt renamed 'tempfile_mv.txt' -> 'tempfile_mv_v.txt' 建立一个空文本文件：touch kelee@ubuntu:~$ ls Desktop Downloads Music Public tempfile_mv_v.txt Templates Documents examples.desktop Pictures riscv tempfile.txt Videos kelee@ubuntu:~$ touch file1.txt kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt Videos Documents file1.txt Public tempfile.txt Downloads Music riscv Templates 建立一个目录：mkdir kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt Videos Documents file1.txt Public tempfile.txt Downloads Music riscv Templates kelee@ubuntu:~$ mkdir test_dir kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt test_dir Documents file1.txt Public tempfile.txt Videos Downloads Music riscv Templates 删除文件/目录：rm kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt test_dir Documents file1.txt Public tempfile.txt Videos Downloads Music riscv Templates kelee@ubuntu:~$ rm tempfile_mv_v.txt kelee@ubuntu:~$ ls -p Desktop/ examples.desktop Pictures/ tempfile.txt Videos/ Documents/ file1.txt Public/ Templates/ Downloads/ Music/ riscv/ test_dir/ kelee@ubuntu:~$ rm test_dir rm: cannot remove 'test_dir': Is a directory kelee@ubuntu:~$ rm -R test_dir kelee@ubuntu:~$ ls Desktop Downloads file1.txt Pictures riscv Templates Documents examples.desktop Music Public tempfile.txt Videos 在上面的操作：首先我们通过ls命令查询可知当前目下有两个文件和一个文件夹； [1] 你可以用参数 -p来让系统显示某一项的类型，比如是文件/文件夹/快捷链接等等； [2] 接下来我们用rm -i尝试删除文件，-i参数是让系统在执行删除操作前输出一条确认提示；i(interactive)也就是交互性的意思； [3] 当我们尝试用上面的命令去删除一个文件夹时会得到错误的提示，因为删除文件夹必须使用-R(recursive,循环）参数 特别提示：在使用命令操作时，系统假设你很明确自己在做什么，它不会给你太多的提示，比如你执行rm -Rf /，它将会删除你硬盘上所有的东西，并且不会给你任何提示，所以，尽量在使用命令时加上-i的参数，以让系统在执行前进行一次确认，防止你干一些蠢事。如 果你觉得每次都要输入-i太麻烦，你可以执行以下的命令，让－i成为默认参数： alias rm='rm -i' 查询当前进程：ps kelee@ubuntu:~$ ps PID TTY TIME CMD 3356 pts/0 00:00:00 bash 3659 pts/0 00:00:00 ps 这条命令会例出你所启动的所有进程； ps -a #可以例出系统当前运行的所有进程，包括由其他用户启动的进程； ps auxww #是一条相当人性化的命令，它会例出除一些很特殊进程以外的所有进程，并会以一个高可读的形式显示结果，每一个进程都会有较为详细的解释； 基本命令的介绍就到此为止，你可以访问网络得到更加详细的Linux命令介绍。 控制流程 输入/输出 input用来读取你通过键盘（或其他标准输入设备）输入的信息，output用于在屏幕（或其他标准输出设备）上输出你指定的输出内容.另外还有一些标准的出错提示也是通过这个命令来实现的。通常在遇到操作错误时，系统会自动调用这个命令来输出标准错误提示； 我们能重定向命令中产生的输入和输出流的位置。 重定向 如果你想把命令产生的输出流指向一个文件而不是（默认的）终端，你可以使用如下的语句： kelee@ubuntu:~$ ls >file2.txt kelee@ubuntu:~$ cat file2.txt Desktop Documents Downloads examples.desktop file1.txt file2.txt Music Pictures Public riscv tempfile.txt Templates Videos 以上例子将创建文件file2.txt如果file2.txt不存在的话。注意：如果file2.txt已经存在，那么上面的命令将复盖文件的内容。如果你想将内容添加到已存在的文件内容的最后，那你可以用下面这个语句： command >> filename 示例: kelee@ubuntu:~$ ls >>file2.txt kelee@ubuntu:~$ cat file2.txt Desktop Documents Downloads examples.desktop file1.txt file2.txt Music Pictures Public riscv tempfile.txt Templates Videos Desktop Documents Downloads examples.desktop file1.txt file2.txt Music Pictures Public riscv tempfile.txt Templates Videos 在这个例子中，你会发现原有的文件中添加了新的内容。接下来我们会见到另一种重定向方式：我们将把一个文件的内容作为将要执行的命令的输入。以下是这个语句： command 示例: kelee@ubuntu:~$ sort 管道 Linux的强大之处在于它能把几个简单的命令联合成为复杂的功能，通过键盘上的管道符号'|' 完成。现在，我们来排序上面的\"grep\"命令： kelee@ubuntu:~$ grep -i 'D' result.txt kelee@ubuntu:~$ cat result.txt Desktop Desktop Documents Documents Downloads Downloads examples.desktop examples.desktop Videos Videos 搜索 file2.txt 中的d字母，将输出分类并写入分类文件到 result.txt 。 有时候用ls列出很多命令的时候很不方便 这时“｜”就充分利用到了 ls -l | less 慢慢看吧. 后台进程 CLI 不是系统的串行接口。您可以在执行其他命令时给出系统命令。要启动一个进程到后台，追加一个“&”到命令后面。 sleep 60 & ls 睡眠命令在后台运行，您依然可以与计算机交互。除了不同步启动命令以外，最好把 '&' 理解成 ';'。 如果您有一个命令将占用很多时间，您想把它放入后台运行，也很简单。只要在命令运行时按下ctrl-z，它就会停止。然后键入 bg使其转入后台。fg 命令可使其转回前台。 sleep 60 # 这表示敲入Ctrl+Z键 bg fg 最后，您可以使用 ctrl-c 来杀死一个前台进程。 环境变量 特殊变量。PATH, PS1, ... 不显示中文 可通过执行如下命令避免显示乱码中文。在一个shell中，执行： export LANG=”” 这样在这个shell中，output信息缺省时英文。 获得软件包 命令行获取软件包 Ubuntu 下可以使用 apt-get 命令，apt-get 是一条 Linux 命令行命令，适用于 deb 包管理式的操作系统，主要用于自动从互联网软件库中搜索、安装、升级以及卸载软件或者操作系统。一般需要 root 执行权限，所以一般跟随 sudo 命令，如： sudo apt-get install gcc [ENTER] 常见的以及常用的 apt 命令有： apt-get install 下载 以及所依赖的软件包，同时进行软件包的安装或者升级。 apt-get remove 移除 以及所有依赖的软件包。 apt-cache search 搜索满足 的软件包。 apt-cache show/showpkg 显示软件包 的完整描述。 例如： kelee@ubuntu:~$ apt-cache search aptitude aptitude - terminal-based package manager aptitude-common - architecture independent files for the aptitude package manager aptitude-doc-en - English manual for aptitude, a terminal-based package manager libcwidget-dev - high-level terminal interface library for C++ (development files) apt-cacher - Caching proxy server for Debian/Ubuntu software repositories apticron - Simple tool to mail about pending package updates - cron version apticron-systemd - Simple tool to mail about pending package updates - systemd version aptitude-doc-cs - Czech manual for aptitude, a terminal-based package manager aptitude-doc-es - Spanish manual for aptitude, a terminal-based package manager aptitude-doc-fi - Finnish manual for aptitude, a terminal-based package manager aptitude-doc-fr - French manual for aptitude, a terminal-based package manager aptitude-doc-it - Italian manual for aptitude, a terminal-based package manager aptitude-doc-ja - Japanese manual for aptitude, a terminal-based package manager aptitude-doc-nl - Dutch manual for aptitude, a terminal-based package manager aptitude-doc-ru - Russian manual for aptitude, a terminal-based package manager aptitude-robot - Automate package choice management cron-apt - automatic update of packages using apt-get cupt - flexible package manager -- console interface gbrainy - brain teaser game and trainer to have fun and to keep your brain trained pkgsync - automated package list synchronization wajig - unified package management front-end for Debian kelee@ubuntu:~$ 配置升级源 Ubuntu的软件包获取依赖升级源，通过Software&Updates->Ubuntu Software->Download from:->Other:->China->mirrors.aliyun.com->Choose Server 查找帮助文件 Ubuntu 下提供 man 命令以完成帮助手册得查询。man 是 manual 的缩写，通过 man 命令可以对 Linux 下常用命令、安装软件、以及C语言常用函数等进行查询，获得相关帮助。 例如： kelee@ubuntu:~$ man printf PRINTF(1) User Commands PRINTF(1) NAME printf - format and print data SYNOPSIS printf FORMAT [ARGUMENT]... printf OPTION DESCRIPTION Print ARGUMENT(s) according to FORMAT, or execute according to OPTION: --help display this help and exit --version output version information and exit FORMAT controls the output as in C printf. Interpreted sequences are: \\\" double quote \\\\ backslash Manual page printf(1) line 1 (press h for help or q to quit) 通常可能会用到的帮助文件例如： gcc-doc cpp-doc glibc-doc 上述帮助文件可以通过 apt-get 命令或者软件包管理器获得。获得以后可以通过 man 命令进行命令或者参数查询。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-18 11:30:03 "},"Lab0/前导知识/了解开发调试基本工具.html":{"url":"Lab0/前导知识/了解开发调试基本工具.html","title":"了解开发调试基本工具","keywords":"","body":"了解开发调试基本工具 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:08:24 "},"Lab0/前导知识/了解硬件模拟器.html":{"url":"Lab0/前导知识/了解硬件模拟器.html","title":"了解硬件模拟器","keywords":"","body":"了解硬件模拟器 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:08:24 "},"Lab0/配置环境.html":{"url":"Lab0/配置环境.html","title":"配置环境","keywords":"","body":"配置环境 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:08:24 "},"Lab0/配置环境/安装虚拟环境.html":{"url":"Lab0/配置环境/安装虚拟环境.html","title":"安装虚拟环境","keywords":"","body":"安装虚拟环境 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:08:24 "},"Lab0/配置环境/安装开发工具.html":{"url":"Lab0/配置环境/安装开发工具.html","title":"安装开发工具","keywords":"","body":"安装开发工具 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:08:24 "},"Lab0/配置环境/安装依赖包.html":{"url":"Lab0/配置环境/安装依赖包.html","title":"安装依赖包","keywords":"","body":"安装依赖包 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:08:24 "},"Lab0/配置环境/安装硬件模拟器.html":{"url":"Lab0/配置环境/安装硬件模拟器.html","title":"安装硬件模拟器","keywords":"","body":"安装硬件模拟器 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:08:24 "},"Lab0/配置环境/安装调试工具.html":{"url":"Lab0/配置环境/安装调试工具.html","title":"安装调试工具","keywords":"","body":"安装调试工具 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:08:24 "},"Lab0/附录.html":{"url":"Lab0/附录.html","title":"附录","keywords":"","body":"附录 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 10:08:24 "},"Lab0/准备知识.html":{"url":"Lab0/准备知识.html","title":"准备知识","keywords":"","body":"准备知识 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab0/了解OS实验.html":{"url":"Lab0/了解OS实验.html","title":"了解OS实验","keywords":"","body":"了解OS实验 写一个操作系统难吗？别被现在上百万行的Linux和Windows操作系统吓倒。当年Thompson趁他老婆带着小孩度假留他一人在家时，写了UNIX；当年Linus还是一个21岁大学生时完成了Linux雏形。站在这些巨人的肩膀上，我们能否也尝试一下做“巨人”的滋味呢？ MIT的Frans Kaashoek等在2006年参考PDP-11上的UNIX Version 6写了一个可在X86上跑的操作系统xv6（基于MIT License），用于学生学习操作系统。我们可以站在他们的肩膀上，基于xv6的设计，尝试着一步一步完成一个从“空空如也”到“五脏俱全”的“麻雀”操作系统——ucore，此“麻雀”包含虚存管理、进程管理、处理器调度、同步互斥、进程间通信、文件系统等主要内核功能，总的内核代码量（C+asm）不会超过5K行。充分体现了“小而全”的指导思想。 ucore的运行环境可以是真实的计算机（包括小型智能设备），不过考虑到调试和开发的方便，我们可采用硬件模拟器，比如QEMU、BOCHS、VirtualBox、VMware Player等。。ucore的开发环境主要是GCC中的gcc、gas、ld和MAKE等工具，在分析源代码上，可以采用Scitools提供的understand软件（跨平台）、VSCode（跨平台），windows环境上的source insight软件，或者基于emacs+ctags，vim+ctags等，都可以比较方便在在一堆文件中查找变量、函数定义、调用/访问关系等。软件开发的版本管理可以采用GIT、SVN等。比较文件和目录的不同可发现不同实验中的差异性和进行文件合并操作，可使用meld、kdiff3、UltraCompare等软件。调试（deubg）实验有助于发现设计中的错误，可采用gdb（配合qemu）等调试工具软件。并可整个实验的运行环境和开发环境在Linux环境中使用。 那我们准备如何一步一步来实现ucore呢？根据一个操作系统的设计实现过程，我们可以有如下的实验步骤： 启动操作系统的bootloader：OpenSBI。了解操作系统启动前的状态和要做的准备工作，了解运行操作系统的硬件支持，操作系统如何加载到内存中，理解两类中断--“外设中断”，“陷阱中断”等； 物理内存管理子系统。用于理解RISC-V分段/分页模式，了解操作系统如何管理物理内存； 虚拟内存管理子系统。通过页表机制和换入换出（swap）机制，以及中断-“故障中断”、缺页故障处理等，实现基于页的内存替换算法； 内核线程子系统。用于了解如何创建相对与用户进程更加简单的内核态线程，如果对内核线程进行动态管理等； 用户进程管理子系统。用于了解用户态进程创建、执行、切换和结束的动态管理过程，了解在用户态通过系统调用得到内核态的内核服务的过程； 处理器调度子系统。用于理解操作系统的调度过程和调度算法； 同步互斥与进程间通信子系统。了解进程间如何进行信息交换和共享，并了解同步互斥的具体实现以及对系统性能的影响，研究死锁产生的原因，以及如何避免死锁； 文件系统。了解文件系统的具体实现，与进程管理等的关系，了解缓存对操作系统IO访问的性能改进，了解虚拟文件系统（VFS）、buffer cache和disk driver之间的关系。 其中每个开发步骤都是建立在上一个步骤之上的，就像搭积木，从一个一个小木块，最终搭出来一个小房子。在搭房子的过程中，完成从理解操作系统原理到实践操作系统设计与实现的探索过程。这个房子最终的建筑架构和建设进度如下图所示： Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-16 16:12:49 "},"Lab0/设置实验环境.html":{"url":"Lab0/设置实验环境.html","title":"设置实验环境","keywords":"","body":"设置实验环境 我们参考了MIT的xv6、Harvard的OS161和Linux等设计了ucore OS实验，所有OS实验需在Linux下运行。对于经验不足的同学，推荐参考“通过虚拟机使用Linux实验环境”一节用虚拟机方式进行试验。 [!NOTE|style:flat] 也有同学在MAC系统和Windows系统中搭建实验环境，不过过程相对比较复杂，这里就不展开介绍了。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-15 12:44:02 "},"Lab0/开发OS实验的简单步骤.html":{"url":"Lab0/开发OS实验的简单步骤.html","title":"开发OS实验的简单步骤","keywords":"","body":"开发OS实验的简单步骤 本次OS实验大致可以通过如下过程就可以完成使用： 学习相关理论知识 建立LAB实验环境，采用VMware虚拟机的最简单方式完成 阅读本LAB实验指导书，了解实验要求 下载源码 进入各个OS实验工程目录 例如：cd labcodes/lab1 根据实验要求阅读并修改代码 编译源码 例如执行：make 如果不通过则返回步骤3 如果实现不正确（即看到步骤6的输出存在不是OK的情况）则返回3 如果实现基本正确（即看到6的输出都是OK）则push到自己github仓库 编写实验报告，发送到助教邮箱，并push到github仓库 另外，可以通过make qemu让OS实验工程在qemu上运行；可以通过make debug或make debug-nox命令实现通过gdb远程调试 OS实验工程。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-29 11:42:12 "},"Lab0/通过虚拟机使用Linux实验环境.html":{"url":"Lab0/通过虚拟机使用Linux实验环境.html","title":"通过虚拟机使用Linux实验环境","keywords":"","body":"通过虚拟机使用Linux实验环境 通过虚拟机进行实验是最容易的实验环境安装方法，这也是最简单的一种通过虚拟机方式使用Linux并完成OS各个实验的方法。具体步骤如下： 首先下载并安装VMware15 客户端（VMware只支持Windows与Linux，MAC需要自己上网查找虚拟机安装教程）。 到清华镜像站下载Ubuntu 18.04.3 的镜像文件。 具体的安装步骤可参考这个教程。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-11 11:52:02 "},"Lab0/安装使用Linux实验环境.html":{"url":"Lab0/安装使用Linux实验环境.html","title":"安装使用Linux实验环境","keywords":"","body":"安装使用Linux实验环境 使用Linux 在实验过程中，我们需要了解基于命令行方式的编译、调试、运行操作系统的实验方法。为此，需要了解基本的Linux命令行使用。 命令模式的基本结构和概念 Ubuntu是图形界面友好和易操作的linux发行版，但有时只需执行几条简单的指令就可以完成繁琐的鼠标点击才能完成的操作。linux的命令行操作模式功能可以实现你需要的所有操作。简单的说，命令行就是基于字符命令的用户界面，也被称为文本操作模式。绝大多数情况下， 用户通过输入一行或多行命令直接与计算机互动，来实现对计算机的操作。 如何进入命令模式 假设使用默认的图形界面为GNOME的任意版本Ubuntu Linux。点击鼠标右键->终端，就可以启动名为terminal程序，从而可以在此软件界面中进行命令行操作。 打开terminal程序后你首先可能会注意到类似下面的界面： kelee@ubuntu:~$ 你所看到的这些被称为命令终端提示符，它表示计算机已就绪，正在等待着用户输入操作指令。以我的屏幕画面为例，“kelee\"是当前所登录的用户名，“ubuntu”是这台计算机的主机名，“~”表示当前目录。此时输入任何指令按回车之后该指令将会提交到计算机运行，比如你可以输入命令：ls 再按下回车： ls [ENTER] 注意：[ENTER]是指输入完ls后按下回车键，而不是叫你输入这个单词，ls这个命令将会列出你当前所在目录里的所有文件和子目录列表。 下面介绍bash shell程序的基本使用方法，它是ubuntu缺省的外壳程序。 常用指令 查询文件列表：(ls) kelee@ubuntu:~$ ls Desktop Downloads Music Public Templates Documents examples.desktop Pictures riscv Videos ls命令默认状态下将按首字母升序列出你当前文件夹下面的所有内容，但这样直接运行所得到的信息也是比较少的，通常它可以结合以下这些参数运行以查询更多的信息： ls / # 将列出根目录'/'下的文件清单.如果给定一个参数，则命令行会把该参数当作命令行的工作目录。换句话说，命令行不再以当前目录为工作目录。 ls -l # 将给你列出一个更详细的文件清单. ls -a # 将列出包括隐藏文件(以.开头的文件)在内的所有文 件. ]ls -h # 将以KB/MB/GB的形式给出文件大小,而不是以纯粹的Bytes. 查询当前所在目录：(pwd) kelee@ubuntu:~$ pwd /home/kelee 进入其他目录：(cd) kelee@ubuntu:~$ cd riscv kelee@ubuntu:~/riscv$ pwd /home/kelee/riscv kelee@ubuntu:~/riscv$ 上面例子中，当前目录原来是/home/kelee,执行cd riscv之后再运行pwd可以发现，当前目录已经改为/riscv了。 在屏幕上输出字符： (echo) kelee@ubuntu:~$ echo \"Hello World\" Hello World 这是一个很有用的命令，它可以在屏幕上输入你指定的参数(\"\"号中的内容)，当然这里举的这个例子中它没有多大的实际意义，但随着你对LINUX指令的不断深入，就会发现它的价值所在。 显示文件内容：cat kelee@ubuntu:~$ cat tempfile.txt Roses are red. Violets are blue, and you have the bird-flue! 也可以使用less或more来显示比较大的文本文件内容。 复制文件： cp kelee@ubuntu:~$ cp tempfile.txt tempfile_copy.txt kelee@ubuntu:~$ cat tempfile_copy.txt Roses are red. Violets are blue, and you have the bird-flue! 移动文件：mv kelee@ubuntu:~$ ls Desktop Downloads Music Public tempfile_copy.txt Templates Documents examples.desktop Pictures riscv tempfile.txt Videos kelee@ubuntu:~$ mv tempfile_copy.txt tempfile_mv.txt kelee@ubuntu:~$ ls Desktop Downloads Music Public tempfile_mv.txt Templates Documents examples.desktop Pictures riscv tempfile.txt Videos 注意：在命令操作时系统基本上不会给你什么提示，当然，绝大多数的命令可以通过加上一个参数-v来要求系统给出执行命令的反馈信息； kelee@ubuntu:~$ mv -v tempfile_mv.txt tempfile_mv_v.txt renamed 'tempfile_mv.txt' -> 'tempfile_mv_v.txt' 建立一个空文本文件：touch kelee@ubuntu:~$ ls Desktop Downloads Music Public tempfile_mv_v.txt Templates Documents examples.desktop Pictures riscv tempfile.txt Videos kelee@ubuntu:~$ touch file1.txt kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt Videos Documents file1.txt Public tempfile.txt Downloads Music riscv Templates 建立一个目录：mkdir kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt Videos Documents file1.txt Public tempfile.txt Downloads Music riscv Templates kelee@ubuntu:~$ mkdir test_dir kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt test_dir Documents file1.txt Public tempfile.txt Videos Downloads Music riscv Templates 删除文件/目录：rm kelee@ubuntu:~$ ls Desktop examples.desktop Pictures tempfile_mv_v.txt test_dir Documents file1.txt Public tempfile.txt Videos Downloads Music riscv Templates kelee@ubuntu:~$ rm tempfile_mv_v.txt kelee@ubuntu:~$ ls -p Desktop/ examples.desktop Pictures/ tempfile.txt Videos/ Documents/ file1.txt Public/ Templates/ Downloads/ Music/ riscv/ test_dir/ kelee@ubuntu:~$ rm test_dir rm: cannot remove 'test_dir': Is a directory kelee@ubuntu:~$ rm -R test_dir kelee@ubuntu:~$ ls Desktop Downloads file1.txt Pictures riscv Templates Documents examples.desktop Music Public tempfile.txt Videos 在上面的操作：首先我们通过ls命令查询可知当前目下有两个文件和一个文件夹； [1] 你可以用参数 -p来让系统显示某一项的类型，比如是文件/文件夹/快捷链接等等； [2] 接下来我们用rm -i尝试删除文件，-i参数是让系统在执行删除操作前输出一条确认提示；i(interactive)也就是交互性的意思； [3] 当我们尝试用上面的命令去删除一个文件夹时会得到错误的提示，因为删除文件夹必须使用-R(recursive,循环）参数 特别提示：在使用命令操作时，系统假设你很明确自己在做什么，它不会给你太多的提示，比如你执行rm -Rf /，它将会删除你硬盘上所有的东西，并且不会给你任何提示，所以，尽量在使用命令时加上-i的参数，以让系统在执行前进行一次确认，防止你干一些蠢事。如 果你觉得每次都要输入-i太麻烦，你可以执行以下的命令，让－i成为默认参数： alias rm='rm -i' 查询当前进程：ps kelee@ubuntu:~$ ps PID TTY TIME CMD 3356 pts/0 00:00:00 bash 3659 pts/0 00:00:00 ps 这条命令会例出你所启动的所有进程； ps -a #可以例出系统当前运行的所有进程，包括由其他用户启动的进程； ps auxww #是一条相当人性化的命令，它会例出除一些很特殊进程以外的所有进程，并会以一个高可读的形式显示结果，每一个进程都会有较为详细的解释； 基本命令的介绍就到此为止，你可以访问网络得到更加详细的Linux命令介绍。 控制流程 输入/输出 input用来读取你通过键盘（或其他标准输入设备）输入的信息，output用于在屏幕（或其他标准输出设备）上输出你指定的输出内容.另外还有一些标准的出错提示也是通过这个命令来实现的。通常在遇到操作错误时，系统会自动调用这个命令来输出标准错误提示； 我们能重定向命令中产生的输入和输出流的位置。 重定向 如果你想把命令产生的输出流指向一个文件而不是（默认的）终端，你可以使用如下的语句： kelee@ubuntu:~$ ls >file2.txt kelee@ubuntu:~$ cat file2.txt Desktop Documents Downloads examples.desktop file1.txt file2.txt Music Pictures Public riscv tempfile.txt Templates Videos 以上例子将创建文件file2.txt如果file2.txt不存在的话。注意：如果file2.txt已经存在，那么上面的命令将复盖文件的内容。如果你想将内容添加到已存在的文件内容的最后，那你可以用下面这个语句： command >> filename 示例: kelee@ubuntu:~$ ls >>file2.txt kelee@ubuntu:~$ cat file2.txt Desktop Documents Downloads examples.desktop file1.txt file2.txt Music Pictures Public riscv tempfile.txt Templates Videos Desktop Documents Downloads examples.desktop file1.txt file2.txt Music Pictures Public riscv tempfile.txt Templates Videos 在这个例子中，你会发现原有的文件中添加了新的内容。接下来我们会见到另一种重定向方式：我们将把一个文件的内容作为将要执行的命令的输入。以下是这个语句： command 示例: kelee@ubuntu:~$ sort 管道 Linux的强大之处在于它能把几个简单的命令联合成为复杂的功能，通过键盘上的管道符号'|' 完成。现在，我们来排序上面的\"grep\"命令： kelee@ubuntu:~$ grep -i 'D' result.txt kelee@ubuntu:~$ cat result.txt Desktop Desktop Documents Documents Downloads Downloads examples.desktop examples.desktop Videos Videos 搜索 file2.txt 中的d字母，将输出分类并写入分类文件到 result.txt 。 有时候用ls列出很多命令的时候很不方便 这时“｜”就充分利用到了 ls -l | less 慢慢看吧. 后台进程 CLI 不是系统的串行接口。您可以在执行其他命令时给出系统命令。要启动一个进程到后台，追加一个“&”到命令后面。 sleep 60 & ls 睡眠命令在后台运行，您依然可以与计算机交互。除了不同步启动命令以外，最好把 '&' 理解成 ';'。 如果您有一个命令将占用很多时间，您想把它放入后台运行，也很简单。只要在命令运行时按下ctrl-z，它就会停止。然后键入 bg使其转入后台。fg 命令可使其转回前台。 sleep 60 # 这表示敲入Ctrl+Z键 bg fg 最后，您可以使用 ctrl-c 来杀死一个前台进程。 环境变量 特殊变量。PATH, PS1, ... 不显示中文 可通过执行如下命令避免显示乱码中文。在一个shell中，执行： export LANG=”” 这样在这个shell中，output信息缺省时英文。 获得软件包 命令行获取软件包 Ubuntu 下可以使用 apt-get 命令，apt-get 是一条 Linux 命令行命令，适用于 deb 包管理式的操作系统，主要用于自动从互联网软件库中搜索、安装、升级以及卸载软件或者操作系统。一般需要 root 执行权限，所以一般跟随 sudo 命令，如： sudo apt-get install gcc [ENTER] 常见的以及常用的 apt 命令有： apt-get install 下载 以及所依赖的软件包，同时进行软件包的安装或者升级。 apt-get remove 移除 以及所有依赖的软件包。 apt-cache search 搜索满足 的软件包。 apt-cache show/showpkg 显示软件包 的完整描述。 例如： kelee@ubuntu:~$ apt-cache search aptitude aptitude - terminal-based package manager aptitude-common - architecture independent files for the aptitude package manager aptitude-doc-en - English manual for aptitude, a terminal-based package manager libcwidget-dev - high-level terminal interface library for C++ (development files) apt-cacher - Caching proxy server for Debian/Ubuntu software repositories apticron - Simple tool to mail about pending package updates - cron version apticron-systemd - Simple tool to mail about pending package updates - systemd version aptitude-doc-cs - Czech manual for aptitude, a terminal-based package manager aptitude-doc-es - Spanish manual for aptitude, a terminal-based package manager aptitude-doc-fi - Finnish manual for aptitude, a terminal-based package manager aptitude-doc-fr - French manual for aptitude, a terminal-based package manager aptitude-doc-it - Italian manual for aptitude, a terminal-based package manager aptitude-doc-ja - Japanese manual for aptitude, a terminal-based package manager aptitude-doc-nl - Dutch manual for aptitude, a terminal-based package manager aptitude-doc-ru - Russian manual for aptitude, a terminal-based package manager aptitude-robot - Automate package choice management cron-apt - automatic update of packages using apt-get cupt - flexible package manager -- console interface gbrainy - brain teaser game and trainer to have fun and to keep your brain trained pkgsync - automated package list synchronization wajig - unified package management front-end for Debian kelee@ubuntu:~$ 配置升级源 Ubuntu的软件包获取依赖升级源，通过Software&Updates->Ubuntu Software->Download from:->Other:->China->mirrors.aliyun.com->Choose Server 查找帮助文件 Ubuntu 下提供 man 命令以完成帮助手册得查询。man 是 manual 的缩写，通过 man 命令可以对 Linux 下常用命令、安装软件、以及C语言常用函数等进行查询，获得相关帮助。 例如： kelee@ubuntu:~$ man printf PRINTF(1) User Commands PRINTF(1) NAME printf - format and print data SYNOPSIS printf FORMAT [ARGUMENT]... printf OPTION DESCRIPTION Print ARGUMENT(s) according to FORMAT, or execute according to OPTION: --help display this help and exit --version output version information and exit FORMAT controls the output as in C printf. Interpreted sequences are: \\\" double quote \\\\ backslash Manual page printf(1) line 1 (press h for help or q to quit) 通常可能会用到的帮助文件例如： gcc-doc cpp-doc glibc-doc 上述帮助文件可以通过 apt-get 命令或者软件包管理器获得。获得以后可以通过 man 命令进行命令或者参数查询。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-04 11:49:28 "},"Lab0/实验中可能使用的软件.html":{"url":"Lab0/实验中可能使用的软件.html","title":"实验中可能使用的软件","keywords":"","body":"实验中可能使用的软件 编辑器 自带的编辑器 Ubuntu 下自带的编辑器可以作为代码编辑的工具。例如 gedit 是 gnome 桌面环境下兼容UTF-8的文本编辑器。它十分的简单易用，有良好的语法高亮，对中文支持很好。通常可以通过双击或者命令行打开目标文件进行编辑。 Vim 编辑器 Vim是一款极方便的文本编辑软件，是UNIX下的同类型软件VI的改进版本。Vim经常被看作是“专门为程序员打造的文本编辑器”，功能强大且方便使用，便于进行程序开发。 Ubuntu 下默认安装的 vi 版本较低，功能较弱，建议在系统内安装或者升级到最新版本的 Vim。 关于Vim的常用命令以及使用，可以通过网络进行查找。 配置文件：Vim 的使用需要配置文件进行设置，例如： set nocompatible set encoding=utf-8 set fileencodings=utf-8,chinese set tabstop=4 set cindent shiftwidth=4 set backspace=indent,eol,start autocmd Filetype c set omnifunc=ccomplete#Complete autocmd Filetype cpp set omnifunc=cppcomplete#Complete set incsearch set number set display=lastline set ignorecase syntax on set nobackup set ruler set showcmd set smartindent set hlsearch set cmdheight=1 set laststatus=2 set shortmess=atI set formatoptions=tcrqn set autoindent 可以将上述配置文件保存到： ~/.vimrc 注意：.vimrc 默认情况下隐藏不可见，可以在命令行中通过 “ls -a” 命令进行查看。如果 '~' 目录下不存在该文件，可以手动创建。修改该文件以后，重启 Vim 可以使配置生效。 VScode VScode是很好的项目管理、代码编译器工具，集成了git，并且可以安装各类插件支持各种语言，习惯使用visual studio的同学使用起来会非常习惯，具体的下载安装使用方法，可以参考该教程，值得说明的是，我们在编译的时候需要其他工具联合编译，因此可以仅仅把VScode当成没有感情的写代码工具，不由它来编译运行，编译运行交给终端。 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-07-10 11:38:20 "},"Lab1/":{"url":"Lab1/","title":"LAB1","keywords":"","body":"Lab1 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab1/实验目的.html":{"url":"Lab1/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab1/实验内容.html":{"url":"Lab1/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab2/":{"url":"Lab2/","title":"LAB2","keywords":"","body":"Lab2 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab2/实验目的.html":{"url":"Lab2/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab2/实验内容.html":{"url":"Lab2/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab3/":{"url":"Lab3/","title":"LAB3","keywords":"","body":"Lab3 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab3/实验目的.html":{"url":"Lab3/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab3/实验内容.html":{"url":"Lab3/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab4/":{"url":"Lab4/","title":"LAB4","keywords":"","body":"Lab4 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab4/实验目的.html":{"url":"Lab4/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab4/实验内容.html":{"url":"Lab4/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab5/":{"url":"Lab5/","title":"LAB5","keywords":"","body":"Lab5 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab5/实验目的.html":{"url":"Lab5/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab5/实验内容.html":{"url":"Lab5/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab6/":{"url":"Lab6/","title":"LAB6","keywords":"","body":"Lab6 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab6/实验目的.html":{"url":"Lab6/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab6/实验内容.html":{"url":"Lab6/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab7/":{"url":"Lab7/","title":"LAB7","keywords":"","body":"Lab7 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab7/实验目的.html":{"url":"Lab7/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab7/实验内容.html":{"url":"Lab7/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab8/":{"url":"Lab8/","title":"LAB8","keywords":"","body":"Lab8 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab8/实验目的.html":{"url":"Lab8/实验目的.html","title":"实验目的","keywords":"","body":"实验目的 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "},"Lab8/实验内容.html":{"url":"Lab8/实验内容.html","title":"实验内容","keywords":"","body":"实验内容 Copyright © 2020 all right reserved，powered by Gitbook最后修订于： 2020-06-21 20:00:49 "}}